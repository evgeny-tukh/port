/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

var Cary = { checkMap: checkMap, tools: {}, controls: {}, symbols: {}, settings: {}, userObjects: {}, drawers: {}, ui: {}, geo: {} };

Cary.symbols.cross         = '✖';
Cary.symbols.check         = '✔';
Cary.symbols.square        = '◻';
Cary.symbols.filledSquare  = '◼';
Cary.symbols.crossedSquare = '⊠';
Cary.symbols.radioOff      = '◎';
Cary.symbols.radioOn       = '◉';
Cary.symbols.circle        = '◯';
Cary.symbols.filledCircle  = '⚫';
Cary.symbols.unchecked     = '☐';
Cary.symbols.checked       = '☑';
Cary.symbols.crossed       = '☒';
Cary.symbols.heavyCheck    = '✅';
Cary.symbols.heavyCross    = '❎';
Cary.symbols.crossMark     = '❌';
Cary.symbols.raisedHand    = '✋';
Cary.symbols.raisedFist    = '✊';
Cary.symbols.toLeft2       = '«';
Cary.symbols.toLeft3       = '⋘';
Cary.symbols.toRight2      = '»';
Cary.symbols.toRight3      = '⋙';
Cary.symbols.degree        = '°';
Cary.symbols.rightArrow    = '►';
Cary.symbols.downArrow     = '▼';
Cary.symbols.magnifier1    = '🔍';
Cary.symbols.magnifier2    = '🔎';
Cary.symbols.magnifier3    = '&#x1F50D;';
Cary.symbols.magnifier4    = '&#x1F50E;';
Cary.symbols.clip          = '📎'; // '&#128206;';

function checkMap (map)
{
    return (map !== null && 'map' in map) ? map.map : map;
}

Cary.Map = function ()
{
    this.map        = null;
    this.mapDiv     = null;
    this.locker     = null;
    this.globals    = {};
    this.mapOptions = { center: { lat: 59.921209, lng: 30.199651 },
                        clickableIcons: false,
                        disableDefaultUI: true,
                        keyboardShortcuts: false,
                        mapTypeControl: false,
                        panControl: false,
                        rotateControl: false,
                        scaleControl: false,
                        streetViewControl: false,
                        zoom: 10 };
};

Cary.Map.prototype.addEventListener = function (eventName, handler, once)
{
    var listener;
    
    if (Cary.tools.isNothing (once))
        once = false;
    
    if (this.map !== null)
    {
        if (once)
            listener = google.maps.event.addListenerOnce (this.map, eventName, handler);
        else
            listener = google.maps.event.addListener (this.map, eventName, handler);
    }
    else
    {
        listener = null;
    }
    
    return listener;
};

Cary.Map.prototype.addDomListener = function (eventName, handler)
{
    var listener;
    
    if (this.map !== null)
        listener = google.maps.event.addDomListener (this.map, eventName, handler);
    else
        listener = null;
    
    return listener;
};

Cary.Map.prototype.stopEventListener = function (listener)
{
    google.maps.event.removeListener (listener);
};

Cary.Map.prototype.attach = function (div)
{
    this.mapDiv = div;
};

Cary.Map.prototype.zoomIn = function ()
{
    if (this.map !== null)
        this.map.setZoom (this.map.getZoom () + 1);
};

Cary.Map.prototype.zoomOut = function ()
{
    if (this.map !== null)
    {
        var curZoom = this.map.getZoom ();
        
        if (curZoom > 0)
            this.map.setZoom (curZoom - 1);
    }
};

Cary.Map.prototype.createMap = function ()
{
    this.map = new google.maps.Map (this.mapDiv, this.mapOptions);
    
    //if (this.locker === null)
    //    this.locker = new Cary.controls.MapLocker (this.map, false);
};

Cary.Map.prototype.setupPredefinedBaseMaps = function (mask)
{
    if (Cary.tools.isNothing (mask))
        mask = Cary.maps.baseMaps.AllMaps;
    
    Cary.maps.baseMaps.addToMap (this.map, mask);
};

Cary.Map.prototype.enumPredefinedBaseMaps = function (callback)
{
    Cary.maps.baseMaps.predefinedMaps.forEach (callback);    
};

Cary.Map.prototype.enumPredefinedOverlayMaps = function (callback)
{
    Cary.maps.overlayMaps.predefinedMaps.forEach (callback);    
};

Cary.Map.prototype.selectBaseMap = function (index)
{
    Cary.maps.baseMaps.select (this.map, index);
};

Cary.Map.prototype.showOverlayLayer = function (index, show)
{
    Cary.maps.overlayMaps.showOverlayLayer (this.map, index, show);
};

Cary.Map.prototype.isOverlayLayerVisible = function (index)
{
    return Cary.maps.overlayMaps.isOverlayLayerVisible (this.map, index);
};

Cary.Map.prototype.createPosIndicator = function (location, options)
{
    return new Cary.controls.PosIndicator (this.map, location, options);
};

Cary.Map.prototype.createImgButton = function (location, imgSource, options)
{
    return new Cary.controls.ImgButton (this.map, location, imgSource, options);
};

Cary.Map.prototype.createMapMenu = function (position, items, options)
{
    return new Cary.controls.MapMenu (this.map, position, items, options);
};

Cary.Map.prototype.createGMPanel = function (location, options)
{
    return new Cary.controls.GMPanel (this.map, location, options);
};

Cary.Map.prototype.addCustomBaseMap = function (mapID, tileSource, flag)
{
    Cary.maps.baseMaps.predefinedMaps.push ( new Cary.maps.baseMaps.CustomMapType (mapID, tileSource, flag));
};

Cary.Map.prototype.getBaseMapIndex = function (flag)
{
    return Cary.maps.baseMaps.getBaseMapIndex (flag);
};

Cary.Map.prototype.getOverlayIndex = function (flag)
{
    return Cary.maps.overlayMaps.getOverlayIndex (flag);
};

Cary.Map.prototype.removeControl = function (control)
{
    control.remove (this.map);
};

Cary.Map.prototype.lock = function (onClick)
{
    if (Cary.tools.isNothing (onClick))
        onClick = null;
    
    if (this.locker === null)
        this.locker = new Cary.controls.MapLocker (this.map, true, onClick);
    
    this.locker.show (true);
};

Cary.Map.prototype.unlock = function ()
{
    if (this.locker !== null)
        this.locker.show (false);
};

Cary.Map.prototype.drawUserObject = function (object, show)
{
    if (Cary.tools.isNothing (object.drawer))
        object.drawer = object.createDrawer ();
    
    if (Cary.tools.isNothing (show))
        show = true;
    
    object.beforeShowHide (show);
    
    if (show)
        object.drawer.draw (this.map);
    else
        object.drawer.undraw ();
};

Cary.Map.prototype.insertIcon = function (name, lat, lon, options, factory, iconData)
{
    var props = {};
    var icon;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    if ('path' in options)
        props.path = options.path;

    if (Cary.tools.isNothing (factory))
        factory = function (name, lat, lom, props)
                  {
                      return new Cary.userObjects.UserIcon (name, { lat: lat, lon: lon }, props);
                  };

    icon = factory (name, lat, lon, props, iconData);
    
    if ('visible' in options && options.visible)
    {
        icon.drawer = icon.createDrawer ();
        
        icon.drawer.draw (this.map);
    }
    
    return icon;
};

Cary.Map.prototype.clientToMap = function (x, y)
{
    var point = this.clientToGeo (x, y);
    
    return { lat: point.lat (), lon: point.lng () };
};

Cary.Map.prototype.Interface = function (callbacks)
{
    if (Cary.tools.isNothing (callbacks))
        callbacks = {};
    
    for (var key in callbacks)
        this [key] = callbacks [key];
};

Cary.Map.prototype.getPolylineBounds = function (points)
{
    var result;
    
    if (points && points.length > 0)
    {
        var point  = { lat: points [0].lat, lng: points [0].lon };
        var bounds = new google.maps.LatLngBounds (point, point);
        var i;
        
        for (i = 1; i < points.length; ++ i)
            bounds.extend ({ lat: points [i].lat, lng: points [i].lon });
        
        result = bounds;
    }
    else
    {
        result = null;
    }
    
    return result;
};

Cary.Map.prototype.localizePolyline = function (points)
{
    if (points)
    {
        if (points.length === 1)
        {
            this.map.setCenter ({ lat: points [0].lat, lng: points [0].lon });
            this.map.setZoom (16);
        }
        else if (points.length > 0)
        {
            var point  = { lat: points [0].lat, lng: points [0].lon };
            var bounds = new google.maps.LatLngBounds (point, point);
            var i;
        
            for (i = 1; i < points.length; ++ i)
                bounds.extend ({ lat: points [i].lat, lng: points [i].lon });

            this.map.fitBounds (bounds);
        }
    }
};

Cary.Map.prototype.plotPolyline = function (startX, startY, callbacks, tempLegColor, initialObject, objectType, userType, createUserObject)
{
    var start     = this.clientToGeo (startX, startY);
    var points    = [{ lat: start.lat (), lon: start.lng () }];
    var object    = Cary.tools.isNothing (initialObject) ? this.createUserPolyline ('New object', points, null, objectType, userType, createUserObject) : initialObject;
    var drawer    = object.createDrawer ();
    var mouseMove = this.addEventListener ('mousemove', onMouseMove);
    var click     = this.addEventListener ('click', onClick);
    var tempLeg   = null;
    var instance  = this;
    var interface = new Cary.Map.prototype.Interface ({ stop: stop, save: save, changePoint: changePoint, newPoint: newPoint, deletePoint: deletePoint,
                                                        getObject: function () { return object; }, drawDraggable: drawDraggable });
    var balloon   = new Cary.controls.Balloon (this, { x: startX, y: startY, horOffset: 20, verOffset: 20, text: 'aaa' });
    
    object.drawer = drawer;
    
    //drawer.draw (instance.map);
    drawDraggable (callbacks);
    
    if ('onNewPoint' in callbacks)
        callbacks.onNewPoint (start.lat (), start.lng ());
        
    if (Cary.tools.isNothing (callbacks))
        callbacks = {};
    
    if (Cary.tools.isNothing (tempLegColor))
        tempLegColor = 'red';
    
    return interface;
    
    function changePoint (index, point)
    {
        drawer.undraw ();
        
        if (tempLeg !== null)
        {
            tempLeg.setMap (null);
        
            tempLeg = null;
        }
        
        object.points [index].lat = point.lat;
        object.points [index].lon = point.lon;
        
        drawer.draw (instance.map);
    }
    
    function newPoint (point)
    {
        drawer.undraw ();
        
        if (tempLeg !== null)
        {
            tempLeg.setMap (null);
        
            tempLeg = null;
        }
        
        object.points.push ({ lat: point.lat, lon: point.lon });

        //drawer.draw (instance.map);
        drawDraggable (callbacks);
    }
    
    function deletePoint (index)
    {
        drawer.undraw ();
        
        if (tempLeg !== null)
        {
            tempLeg.setMap (null);
        
            tempLeg = null;
        }
        
        object.points.splice (index, 1);

        //drawer.draw (instance.map);
        drawDraggable (callbacks);
    }
    
    function stop ()
    {
        instance.stopEventListener (mouseMove);
        instance.stopEventListener (click);

        // Mark handlers as invalid
        mouseMove = null;
        click     = null;
        
        if (drawer !== null)
            drawer.undraw ();
        
        if (tempLeg !== null)
        {
            tempLeg.setMap (null);

            tempLeg = null;
        }
        
        if (balloon !== null)
        {
            balloon.close ();
            
            balloon = null;
        }
    }

    function drawDraggable (callbacks)
    {
        var options = { editMode: true, draggable: true, noBalloon: true };
        
        for (var key in callbacks)
            options [key] = callbacks [key];
        
        drawer.undraw ();
        drawer.draw (instance.map, options);
    }
    
    function save ()
    {
        object.save ();
    }
    
    function onClick (event)
    {
        // Process only if the handler is not cancelled "on a fly:
        if (click !== null)
        {
            var lat = event.latLng.lat ();
            var lon = event.latLng.lng ();

            drawer.undraw ();

            if (tempLeg !== null)
            {
                tempLeg.setMap (null);

                tempLeg = null;
            }

            object.points.push ({ lat: lat, lon: lon });

            if ('onNewPoint' in callbacks)
                callbacks.onNewPoint (lat, lon);

            // The handler might be cancelled during onNewPoint so we check again
             if (click !== null)
                 drawDraggable (callbacks);
                 //drawer.draw (instance.map);
        }
    }
    
    function onMouseMove (event)
    {
        // Process only if the handler is not cancelled "on a fly:
        if (mouseMove !== null)
        {
            var lastPoint = object.getLastPoint ();
            var points    = [{ lat: lastPoint.lat, lng: lastPoint.lon }, event.latLng];
            var rangeBrg  = Cary.geo.calcRLRangeAndBearing2 (lastPoint.lat, lastPoint.lon, event.latLng.lat (), event.latLng.lng ());

            if (tempLeg !== null)
                tempLeg.setMap (null);

            tempLeg = Cary.drawers.PolylineDrawer.drawGeoPolyline (instance.map, points, { color: tempLegColor, lineWidth: 3, style: Cary.userObjects.lineStyles.DASH });

            balloon.setPosition (event.latLng.lat (), event.latLng.lng ());
            balloon.setText ((rangeBrg.range * 1.852).toFixed (3) + 'km\n' + Cary.tools.formatFloatWithLZ (rangeBrg.bearing, 5, 1) + Cary.symbols.degree);
        }
    }
};

Cary.tools.getTimestamp = function ()
{
    return new Date ().getTime ();
};
    
Cary.tools.dateAddDays = function (timestamp, numOfDays)
{
    return new Date (timestamp + numOfDays * 24 * 3600000).getTime ();
};
    
Cary.tools.formatDate = function (timestamp)
{
    var dateTime = new Date (timestamp);
    
    return Cary.tools.formatNumberWithLZ (dateTime.getDate (), 2) + '.' + 
           Cary.tools.formatNumberWithLZ (dateTime.getMonth () + 1, 2) + '.' + 
           Cary.tools.formatNumberWithLZ (dateTime.getFullYear (), 4);
};

Cary.tools.formatDateTime = function (timestamp)
{
    var dateTime = new Date (timestamp);
    
    return Cary.tools.formatNumberWithLZ (dateTime.getDate (), 2) + '.' + 
           Cary.tools.formatNumberWithLZ (dateTime.getMonth () + 1, 2) + '.' + 
           Cary.tools.formatNumberWithLZ (dateTime.getFullYear (), 4) + ' ' + 
           Cary.tools.formatNumberWithLZ (dateTime.getHours (), 2) + ':' + 
           Cary.tools.formatNumberWithLZ (dateTime.getMinutes (), 2) + ':' + 
           Cary.tools.formatNumberWithLZ (dateTime.getSeconds (), 2);
};

Cary.tools.DAY_INTERVAL = 3600000 * 24;

Cary.tools.formatTimeInterval = function (interval, showSeconds)
{
    var days, hours, minutes, seconds, result;
    
    if (Cary.tools.isNothing (showSeconds))
        showSeconds = false;
    
    days     = Math.floor (interval / Cary.tools.DAY_INTERVAL);
    interval = interval % Cary.tools.DAY_INTERVAL;
    hours    = Math.floor (interval / 3600000);
    interval = interval % 3600000;
    minutes  = Math.floor (interval / 60000);
    seconds  = interval % 60000;
    
    if (days > 0)
        days = days.toString () + 'd ';
    else
        days = '';
    
    if (hours > 0)
        hours = hours.toString () + 'h ';
    else
        hours = '';
    
    if (minutes > 0)
        minutes = minutes.toString () + 'm ';
    else
        minutes = '';
    
    result = days + hours + minutes;
    
    if (showSeconds)
        result += seconds + 's';
    
    return result;
};

Cary.Map.prototype.plotIconGroup = function (startX, startY, callbacks, properties, initialObject)
{
    var start     = this.clientToGeo (startX, startY);
    var points    = [{ lat: start.lat (), lon: start.lng () }];
    var object    = Cary.tools.isNothing (initialObject) ? this.createIconGroup ('New icon group', points, properties) : initialObject;
    var drawer    = object.createDrawer ();
    var click     = this.addEventListener ('click', onClick);
    var instance  = this;
    var interface = { stop: stop, save: save, changePoint: changePoint, newPoint: newPoint, deletePoint: deletePoint, getObject: function () { return object; } };
    
    object.drawer = drawer;
    
    drawer.draw (instance.map);
    
    if ('onNewPoint' in callbacks)
        callbacks.onNewPoint (start.lat (), start.lng ());
        
    if (Cary.tools.isNothing (callbacks))
        callbacks = {};
    
    if (Cary.tools.isNothing (properties))
        properties = {};
    
    return interface;
    
    function changePoint (index, position)
    {
        drawer.undraw ();
        
        object.positions [index].lat = position.lat;
        object.positions [index].lon = position.lon;
        
        drawer.draw (instance.map);
    }
    
    function newPoint (position)
    {
        drawer.undraw ();
        
        object.positions.push ({ lat: position.lat, lon: position.lon });

        drawer.draw (instance.map);
    }
    
    function deletePoint (index)
    {
        drawer.undraw ();
        
        object.positions.splice (index, 1);

        drawer.draw (instance.map);
    }
    
    function stop ()
    {
        instance.stopEventListener (click);
        
        drawer.undraw ();
    }

    function save ()
    {
        object.save ();
    }
    
    function onClick (event)
    {
        var lat = event.latLng.lat ();
        var lon = event.latLng.lng ();
        
        drawer.undraw ();
        
        object.positions.push ({ lat: lat, lon: lon });
    
        if ('onNewPoint' in callbacks)
            callbacks.onNewPoint (lat, lon);
        
        drawer.draw (instance.map);
    }
};

Cary.Map.prototype.geoToClient = function (position)
{
    return Cary.maps.geoToClient (this.map, position);
    /*var projection  = this.map.getProjection ();
    var posPoint    = new google.maps.Point (0, 0),
        centerPoint = new google.maps.Point (0, 0);
    var center      = this.map.getCenter ();
    var tileSize    = (1 << this.map.getZoom ());
    var x,
        y;

    projection.fromLatLngToPoint (position, posPoint);
    projection.fromLatLngToPoint (center, centerPoint);

    x = Number (((posPoint.x - centerPoint.x) * tileSize).toFixed ()) + (this.mapDiv.clientWidth >> 1);
    y = Number (((posPoint.y - centerPoint.y) * tileSize).toFixed ()) + (this.mapDiv.clientHeight >> 1);

    return new google.maps.Point (x, y);*/
};

Cary.Map.prototype.clientToGeo = function (x, y)
{
    var projection  = this.map.getProjection ();
    var center      = this.map.getCenter ();
    var tileSize    = (1 << this.map.getZoom ());
    var centerPoint = new google.maps.Point (0, 0);
    var posPoint    = new google.maps.Point (0, 0);
    
    projection.fromLatLngToPoint (center, centerPoint);
    
    posPoint.x = centerPoint.x + (x - (this.mapDiv.clientWidth >> 1))/ tileSize;
    posPoint.y = centerPoint.y + (y - (this.mapDiv.clientHeight >> 1)) / tileSize;
    
    return projection.fromPointToLatLng (posPoint);
};

Cary.Map.prototype.createUserPolyline = function (name, points, properties, objectType, userType, createUserObject)
{
    var object;
    
    if (!Cary.tools.isNothing (userType))
    {
        if (Cary.tools.isNothing (createUserObject))
            object = null;
        else
            object = createUserObject.apply (this, arguments);
    }
    else
    {
        if (Cary.tools.isNothing (objectType))
            objectType = Cary.userObjects.objectTypes.POLYLINE;

        switch (objectType)
        {
            case Cary.userObjects.objectTypes.POLYLINE:
                object = new Cary.userObjects.UserPolyline (name, points, properties); break;

            case Cary.userObjects.objectTypes.POLYGON:
                object = new Cary.userObjects.UserPolygon (name, points, properties); break;

            default:
                object = null;
        }
    }
    
    return object;
};

Cary.Map.prototype.createIconGroup = function (name, points, properties)
{
    return new Cary.userObjects.UserIconGroup (name, points, properties);
};

Cary.Map.prototype.setCursor = function (cursorType)
{
    this.map.setOptions ({ draggableCursor: cursorType });
};

Cary.Map.prototype.setCenter = function (lat, lon)
{
    this.map.setCenter (new google.maps.LatLng (lat, lon));
};

Cary.Map.prototype.editCoordinate = function (parent, mode, initialValue, callbacks)
{
    new Cary.ui.CoordEditWnd (parent, { mode: mode, value: initialValue }, callbacks);
};

Cary.Map.prototype.showFromJSON = function (text)
{
    var object = Cary.userObjects.createFromJSON (text);
    
    if (object !== null)
    {
        var drawer = object.createDrawer ();
        
        drawer.draw (this.map);
    }
};

Cary.Map.prototype.createMFBalloon = function (position, options)
{
    return new Cary.controls.MFBalloon (this.map, position, options);
};

Cary.Map.prototype.showUserObjectCollection = function (collection, show)
{
    var instance = this;
    
    if (Cary.tools.isNothing (show))
        show = true;
    
    if (!Cary.tools.isNothing (collection))
        collection.objects.forEach (function (object)
                                    {
                                        try
                                        {
                                            if (object)
                                                instance.drawUserObject (object, show);
                                        }
                                        catch (err)
                                        {
                                            var errorText = err;
                                        }
                                    });
};

Cary.Map.prototype.setBounds = function (bounds, padding)
{
    this.map.fitBounds (bounds, padding);
}

Cary.Map.prototype.createMarker = function (lat, lon, options)
{
    var color;
    var markerOptions;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    color         = 'color' in options ? options.color : 'black';
    markerOptions = { map: this.map, position: { lat: lat, lng: lon }, visible: true };
    
    if ('title' in options)
        markerOptions.title = options.title;
    
    if ('clickable' in options)
        markerOptions.clickable = options.clickable;
    
    if ('visible' in options)
        markerOptions.visible = options.visible;
    
    if ('anchor' in options)
        markerOptions.anchor = new google.maps.Point (options.anchor.x, options.anchor.y);
    
    if ('shape' in options)
        markerOptions.icon = { fillColor: color, fillOpacity: 1, path: options.shape, strokeColor: color };
    
    if ('icon' in options)
        markerOptions.icon = { url: options.icon };
    
    if ('iconOrigin' in options && 'icon' in markerOptions)
        markerOptions.icon.origin = new google.maps.Point (options.iconOrigin.x, options.iconOrigin.y);
    
    if ('iconAnchor' in options && 'icon' in markerOptions)
        markerOptions.icon.anchor = new google.maps.Point (options.iconAnchor.x, options.iconAnchor.y);
    
    if ('scale' in options && 'icon' in markerOptions)
        markerOptions.icon.scale = options.scale;
    
    if ('size' in options && 'icon' in markerOptions)
    {
        markerOptions.icon.size       = new google.maps.Size (options.size.x, options.size.y);
        markerOptions.icon.scaledSize = new google.maps.Size (options.size.x, options.size.y);
    }
    
    return new google.maps.Marker (markerOptions);
};

Cary.Map.prototype.createPolyline = function (points, options)
{
    var plOptions;

    if (Cary.tools.isNothing (options))
        options = {};
    
    plOptions = { map: this.map, path: [] };
    
    if ('color' in options)
        plOptions.strokeColor = options.color;
    else
        plOptions.strokeColor = 'black';
    
    if ('rhumbline' in options)
        plOptions.geodesic = !options.rhumbline;
    
    if ('visible' in options)
        plOptions.visible = options.visible;
    
    points.forEach (function (point) { plOptions.path.push ({ lat: point.lat, lng: point.lon }); });
    
    return new google.maps.Polyline (plOptions);
};

Cary.Map.prototype.createPolylineEx = function (points, options)
{
    var paths;
    var path;
    var prevTime;
    var maxBreak;
    var i;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    maxBreak = 'maxBreak' in options ? options.maxBreak : 7200000;
    
    for (i = 0, path = [], paths = [], prevTime = 0; i < points.length; ++ i)
    {
        if (Math.abs (points [i].lat) < 0.001 && Math.abs (points [i].lon) < 0.001 || points [i].lat === null || points [i].lon === null)
            continue;
        
        if (prevTime > 0 && (points [i].time - prevTime) > maxBreak)
        {
            if (path.length > 1)
                paths.push (this.createPolyline (path, options));
            
            path = [points [i]];
        }
        else
        {
            path.push (points [i]);
        }
        
        prevTime = points [i].time;
    }
    
    if (path.length > 1)
        paths.push (this.createPolyline (path, options));
    
    return paths;
    /*var plOptions;

    if (Cary.tools.isNothing (options))
        options = {};
    
    plOptions = { map: this.map, path: [] };
    
    if ('color' in options)
        plOptions.strokeColor = options.color;
    else
        plOptions.strokeColor = 'black';
    
    if ('rhumbline' in options)
        plOptions.geodesic = !options.rhumbline;
    
    points.forEach (function (point) { plOptions.path.push ({ lat: point.lat, lng: point.lon }); });
    
    return new google.maps.Polyline (plOptions);*/
};

Cary.Map.prototype.waitForMap = function (callback)
{
    var timer    = setInterval (checkAndCall, 200);
    var instance = this;
    
    function checkAndCall ()
    {
        if (instance.map !== null)
        {
            clearInterval (timer);
            
            if (!Cary.tools.isNothing (callback))
                callback ();
        }
    }
};

Cary.StringTable = function (id, content)
{
    this.id      = id;
    this.strings = {};
    
    if (!Cary.tools.isNothing (content))
        this.loadFromCsv (content);
};

Cary.StringTable.prototype.loadFromCsv = function (content)
{
    var lines = content.split ('\r\n');
    var data  = {};
    
    lines.forEach (function (line)
                   {
                       var values = line.split (',');
                       
                       if (values.length > 1)
                           data [values [0]] = values [1];
                   });
                   
    this.strings = data;
};

Cary.StringTable.prototype.getString = function (id, defValue)
{
    if (Cary.tools.isNothing (defValue))
        defValue = '';
    
    return (id in this.strings) ? this.strings [id] : defValue;
};

Cary.Serializable = function (name)
{
    this.name = name;
    this.id   = 0;
    
    this.keys.forEach (function (key) { this [key] = null; }, this);
};

Cary.Serializable.prototype.keys = [];

Cary.Serializable.prototype.serialize = function ()
{
    var result = { id: this.id, name: this.name };
    
    this.keys.forEach (function (key) { result [key] = this [key]; }, this);

    return result;
};

Cary.Serializable.prototype.deserialize = function (source)
{
    this.name = 'name' in source ? Cary.tools.unicode2char (source.name) : null;
    
    if ('id' in source)
        this.id = source.id;

    this.keys.forEach (function (key)
                       {
                           if (key in source) 
                               this [key] = source [key]; 
                       }, this);
};

Cary.Serializable.prototype.toJSON = function ()
{
    return JSON.stringify (this.serialize ());
};

Cary.Serializable.prototype.fromJSON = function (source)
{
    this.deserialize (JSON.parse (source));
};


Cary.tools.isNothing = function (value)
{
    return typeof  (value) === 'undefined' || value === null;
};

Cary.tools.int2pix = function (value)
{
    return value === null ? null : value.toString () + 'px';
};

Cary.tools.int2perc = function (value)
{
    return value === null ? null : value.toFixed (0) + '%';
};

Cary.tools.round = function (value, precision)
{
    return parseFloat (value.toFixed (precision));
};

Cary.tools.formatNumberWithLZ = function (value, maxDigits)
{
    var stringValue = value.toString ();
    
    while (stringValue.length < maxDigits)
        stringValue = '0' + stringValue;
    
    return stringValue;
};

Cary.tools.formatNumberWithThousandSep = function (value)
{
    var result;
    
    if (Math.abs (value) >= 1000)
    {
        var thousands = Math.trunc (value / 1000);
        var units     = Math.abs (value) - Math.abs (thousands) * 1000;
        
        result = thousands.toString () + ' ' + units.toFixed (0);
    }
    else
    {
        result = value.toFixed (0);
    }
    
    return result;
};

Cary.tools.formatFloatWithLZ = function (value, maxDigits, digitsAfterPoint)
{
    var stringValue = value.toFixed (digitsAfterPoint);
    
    while (stringValue.length < maxDigits)
        stringValue = '0' + stringValue;
    
    return stringValue;
};

Cary.tools.formatLat = function (lat, degChar)
{
    var absLat   = Math.abs (lat);
    var latDeg   = Math.floor (absLat);
    var minLat   = (absLat - latDeg) * 60.0;
    var latHS    = lat >= 0 ? 'N' : 'S';
    
    if (Cary.tools.isNothing (degChar))
        degChar = ' ';
    
    return Cary.tools.formatNumberWithLZ (latDeg, 2) + degChar + Cary.tools.formatFloatWithLZ (minLat, 6, 3) + ' ' + latHS;
};

Cary.tools.formatLon = function (lon, degChar)
{
    var absLon   = Math.abs (lon);
    var lonDeg   = Math.floor (absLon);
    var minLon   = (absLon - lonDeg) * 60.0;
    var lonHS    = lon >= 0 ? 'E' : 'W';
    
    if (Cary.tools.isNothing (degChar))
        degChar = ' ';
    
    return Cary.tools.formatNumberWithLZ (lonDeg, 3) + degChar + Cary.tools.formatFloatWithLZ (minLon, 6, 3) + ' ' + lonHS;
};

Cary.tools.createCssClass = function (className, styles)
{
    var head         = document.getElementsByTagName ('head') [0];
    var styleElement = document.createElement ('style');
    var rules;
    var styleLines = '';
    
    for (var key in styles)
        styleLines += key + ': ' + styles [key] + ';';
    
    
    rules = document.createTextNode ('.' + className + '{' + styleLines + '}');
    
    styleElement.type = 'text/css';
    
    if (styleElement.styleSheet)
        styleElement.styleSheet.cssText = rules.nodeValue;
    else
        styleElement.appendChild (rules);
    
    head.appendChild (styleElement);
    
    return styleElement;
};

Cary.tools.openLink = function (href, newTab)
{
    var link = document.createElement ('a');
    
    if (Cary.tools.isNothing (newTab))
        newTab = false;
    
    link.href = href;
    
    if (newTab)
        link.target = '_blank';

    document.body.appendChild (link);

    setTimeout (function ()
                {
                    var event = document.createEvent ("MouseEvents");

                    event.initMouseEvent ("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

                    link.dispatchEvent (event);

                    document.body.removeChild (link);
                }, 66);
};

Cary.tools.saveFile = function (content, fileName, encoding, escapeContent)
{
    var link = document.createElement ('a');
    var href;
    
    if (Cary.tools.isNothing (encoding))
        encoding = 'utf-8';
    
    if (Cary.tools.isNothing (escapeContent))
        escapeContent = true;
    
    href = "data:'text/plain;' charset="+ encoding + "," + (escapeContent ? escape (content) : content);
    
    link.href = href;

    // For MS Edge
    if (window.navigator.userAgent.indexOf ('Edge') >= 0)
    {
        var blob = new Blob ([content], { type: "application/json" });

        return window.navigator.msSaveBlob (blob, fileName);
    }
        
    // For IE v10
    if (window.MSBlobBuilder)
    {
        var blobBuilder = new MSBlobBuilder ();
        
        blobBuilder.append (content);
        
        return navigator.msSaveBlob (blobBuilder, fileName);
    }
    
    // FireFox v20, Chrome v19
    if ('download' in link)
    {
        link.setAttribute ("download", fileName);
        
        link.innerHTML = "downloading...";
        
        document.body.appendChild (link);
        
        setTimeout (function ()
                    {
                        var event = document.createEvent ("MouseEvents");
            
                        event.initMouseEvent ("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            
                        link.dispatchEvent (event);
            
                        document.body.removeChild (link);
                    }, 66);
                    
        return;
    }
    else
    {
        // Other browsers
        var frame = document.createElement ("iframe");
    
        document.body.appendChild (frame);
    
        frame.src = "data:text/plain" + (window.btoa ? ";base64" : "") + "," + (window.btoa ? window.btoa : escape) (content);
    
        setTimeout (function () { document.body.removeChild (frame); }, 333);
    }
};


Cary.tools.loadFile = function (file, onLoad)
{
    if (window.FileReader)
    {
        var reader = new FileReader ();

        reader.onload = function (event)
                        {
                            onLoad (event.target.result);
                        };

        reader.readAsText (file);
    }
};

Cary.tools.cancelMouseEvent = function (event)
{
    if (window.event.stopPropagation)
        window.event.stopPropagation ();

    if (window.event.preventDefault)
        window.event.preventDefault ();
};

Cary.tools.FileBroswer = function (parent, callbacks, mode)
{
    var instance = this;
    var fileName = null;
    
    if (Cary.tools.isNothing (mode))
        mode = Cary.tools.FileBroswer.readAsText;
    
    this.browser   = document.createElement ('input');
    this.reader    = new FileReader ();
    this.callbacks = Cary.tools.isNothing (callbacks) ? {} : callbacks;

    parent.appendChild (this.browser);
    
    this.browser.type          = 'file';
    this.browser.style.display = 'none';
                            
    this.execute = function ()
    {
        instance = this;
        
        this.cbCalled         = false;
        this.browser.value    = null;
        this.browser.onchange = onBrowserChange;
        this.reader.onload    = onReaderDone;
        this.reader.onloadend = onReaderDone;
        
        this.browser.click ();
    };
    
    function onReaderDone (event)
    {
        if (!instance.cbCalled)
        {
            instance.cbCalled = true;
            
            if ('onSelect' in instance.callbacks)
            {
                instance.callbacks.onSelect (event.target.result, fileName);
            }
        }
    }
    
    function onBrowserChange ()
    {
        var file = instance.browser.files [0];
        
        fileName = file.name;
        
        switch (mode)
        {
            case Cary.tools.FileBroswer.readAsText:
                instance.reader.readAsText (file); break;
                
            case Cary.tools.FileBroswer.readAsBuffer:
                instance.reader.readAsArrayBuffer (file); break;
                
            case Cary.tools.FileBroswer.readAsBinStr:
                instance.reader.readAsBinaryString (file); break;
                
            default:
                instance.reader.readAsDataURL (file);
        }
    }
};

Cary.tools.FileBroswer.readAsText   = 1;
Cary.tools.FileBroswer.readAsBuffer = 2;
Cary.tools.FileBroswer.readAsBinStr = 3;
Cary.tools.FileBroswer.readAsUrl    = 4;

Cary.tools.updateProperty = function (object, name, value)
{
    var result = {};
    
    for (var key in object)
        result [key] = object [key];
    
    result [name] = value;
    
    return result;
};

Cary.tools.unicode2char = function (source)
{
    var regExp = /\\u([\d\w]{4})/gi;
    var result = source.replace (regExp, function (match, group) { return String.fromCharCode (parseInt (group, 16)); } );

    return unescape (result);
};

Cary.tools.checkDecode = function (value)
{
    return (typeof (value) === 'string') ? Cary.tools.unicode2char (value) : value;
};

Cary.tools.insertChildAfter = function (parentObject, newObject, existingObject)
{
    var i;
    
    for (i = 0; i < parentObject.children.length; ++ i)
    {
        if (parentObject.children [i] === existingObject)
        {
            if (i < (parentObject.children.length - 1))
            {
                parentObject.insertBefore (newObject, parentObject.children [i+1]); return;
            }
        }
    }
    
    parentObject.appendChild (newObject);
};

Cary.tools.contentTypes = { json: 'application/json; charset=UTF-8', xml: 'text/xml', plainText: 'text/plain', formData: 'multipart/form-data', urlEncoded: 'application/x-www-form-urlencoded' };
Cary.tools.methods      = { get: 'GET', post: 'POST' };
Cary.tools.resTypes     = { plain: 1, json: 2, xml: 3 };

Cary.tools.sendRequest = function (options)
{
    var request = new XMLHttpRequest ();
    var method  = 'method' in options ? options.method : Cary.tools.methods.post;
    var content = 'content' in options ? options.content : Cary.tools.contentTypes.plainText;
    var resType = 'resType' in options ? options.resType : Cary.tools.resTypes.plain;
    var async   = 'async' in options ? options.async : true;

    request.open (method, options.url, async);
    request.setRequestHeader ('Content-Type', content);

    if ('onLoad' in options)
        request.onload = function ()
                         {
                             var result = (resType === Cary.tools.resTypes.json) ? JSON.parse (this.responseText) : this.responseText;
                                 
                             options.onLoad (result);
                         };

    if ('onError' in options)
        request.onerror = options.onError;

    if (method === Cary.tools.methods.get)
        request.send ();
    else if (content === Cary.tools.contentTypes.json)
        request.send (JSON.stringify (options.param));
    else
        request.send (options.param);
};

Cary.tools.time = function ()
{
    return new Date ().getTime ();
};

Cary.tools.pathRemoveFileName = function (path)
{
    var elements = path.split ('/');
    
    if (elements.length > 1)
        elements.splice (elements.length - 1);
    
    return elements.join ('/');
};

Cary.tools.copyObjectProp = function (dest, source, propName, defValue)
{
    if (Cary.tools.isNothing (defValue))
        defValue = null;
    
    if (propName in source)
        dest [propName] = source [propName];
    else
        dest [propName] = defValue;
};

function circlePath (centerX, centerY, radius)
{
    var diameter = radius + radius;
    
    return 'M ' + centerX + ' ' + centerY + ' m -' + radius + ', 0 a ' + radius + ',' + radius + ' 0 1,0 ' + diameter + ',0 a ' +
           radius + ',' + radius + ' 0 1,0 -' + diameter + ',0';
}

Cary.tools.simpleVesselIconPath = function ()
{
    //return circlePath (0, 0, 5) + ' M 0 -5 L 0 -20 L -5 -15 M 0 -20 L 5 -15';
    //return 'M 0 10 L 5 10 L 5 -5 L 0 -10 L -5 -5 L -5 10 L 0 10';
    return 'M 0 5 L 2 5 L 2 -2 L 0 -5 L -2 -2 L -2 5 L 0 5';
};

Cary.tools.vesselIconPath = function ()
{
    return 'M -4 -3 L -4 6 L -1 10 L 1 10 L 4 6 L 4 -3 L 0 -10 L -4 -3';
    //return circlePath (0, 0, 5) + ' M 0 -5 L 0 -20 L -5 -15 M 0 -20 L 5 -15';
};

Cary.tools.diamondIconPath = function ()
{
    return 'M -7 0 L 0 7 L 7 0 L 0 -7 L -7 0';
};

Cary.tools.smallDiamondIconPath = function ()
{
    return 'M -2 0 L 0 2 L 2 0 L 0 -2 L -2 0';
};

Cary.tools.getHtmlBody = function ()
{
    return document.getElementsByTagName ('body') [0];
};

Cary.tools.findChildByID = function (element, id, fullSearch)
{
    var i, count, result = null, children;
    
    if (!Cary.tools.isNothing (fullSearch))
        fullSearch = false;
    
    if (!Cary.tools.isNothing (element))
    {
        for (i = 0, children = element.children, count = children.length; i < count; ++ i)
        {
            if ('id' in children [i] && children [i].id === id)
            {
                result = children [i]; break;
            }
            
            if (fullSearch && 'children' in fullSearch)
            {
                var subResult = Cary.tools.findChildByID (children [i], id, fullSearch);
                
                if (subResult)
                {
                    result = subResult; break;
                }
            }
        }
    }
    
    return result;
};

Cary.tools.WaitForCondition = function (condition, onElapsed, interval, param)
{
    if (Cary.tools.isNothing (param))
        param = null;
    
    if (condition ())
    {
        if (!Cary.tools.isNothing (onElapsed))
            onElapsed (param);
    }
    else
    {
        var timer = setInterval (checkCondition, Cary.tools.isNothing (interval) ? 500 : interval);

        function checkCondition ()
        {
            if (condition ())
            {
                clearInterval (timer);

                if (!Cary.tools.isNothing (onElapsed))
                    onElapsed (param);
            }
        }
    }
};

Cary.tools.utf8ToAnsi = function (source)
{
    var result;
    var i;
    var byte0, byte1, byte2;

    for (i = 0, result = ''; i < source.length; )
    {
        byte0 = source.charCodeAt (i);

        if (byte0 < 128)
        {
            result += String.fromCharCode (byte0);
            
            i ++;
        }
        else if ((byte0 > 191) && (byte0 < 224))
        {
            byte1   = source.charCodeAt (i+1);
            result += String.fromCharCode(((byte0 & 31) << 6) | (byte1 & 63));
            
            i += 2;
        }
        else 
        {
            byte1   = source.charCodeAt (i+1);
            byte2   = source.charCodeAt (i+2);
            result += String.fromCharCode (((byte0 & 15) << 12) | ((byte1 & 63) << 6) | (byte2 & 63));
            
            i += 3;
        }
    }

    return result;
};

Cary.Service = function (period, param)
{
    this.period   = period;
    this.param    = param;
    this.instance = this;
    this.timer    = null;
};

Cary.Service.prototype.started = function ()
{
    return this.timer !== null;
};
    
Cary.Service.prototype.start = function (callIWorkerImmediately)
{
    if (Cary.tools.isNothing (callIWorkerImmediately))
        callIWorkerImmediately = false;
    
    if (this.timer === null)
    {
        var instance = this;
        
        this.timer = setInterval (function () 
                                  { 
                                      instance.worker (instance.param); 
                                  }, this.period);
        
        if (callIWorkerImmediately)
            this.worker (this.param);
    }
};

Cary.Service.prototype.stop = function ()
{
    if (this.timer !== null)
    {
        clearInterval (this.timer);
        
        this.timer = null;
    }
};

Cary.Service.prototype.worker = function ()
{    
};

function fmod (a, b)
{
    return a % b;
}

function calcDeltaPhi (eccentricity, begLat, endLat)
{
    var ESinBegLat = eccentricity * Math.sin (begLat);
    var ESinEndLat = eccentricity * Math.sin (endLat);

    return Math.log (Math.tan (Math.PI * 0.25 + endLat * 0.5) /
                     Math.tan (Math.PI * 0.25 + begLat * 0.5) *
                     Math.pow (((1.0 - ESinEndLat) * (1.0 + ESinBegLat)) /
                               ((1.0 + ESinEndLat) * (1.0 - ESinBegLat)),
                     eccentricity * 0.5));
}

function square (value)
{
    return value * value;
}

function meridionalPart (lat, eccentricity)
{
    var meridPart, part;

    part      = eccentricity * Math.sin (lat);
    meridPart = Math.log (Math.tan (Math.PI * 0.25 + lat * 0.5)) -
                0.5 * eccentricity * Math.log ((1.0 + part) / (1.0 - part));
    
    return meridPart;
}

function calcMeridionalDist (lat, eccentricity, equRadius)
{
    var md, e2, e4, e6, v1, v2, v3, v4;

    e2 = eccentricity * eccentricity;
    e4 = e2 * e2;
    e6 = e4 * e2;
    v1 = Math.PI / 180.0 * (1.0 - e2 / 4.0 - 3.0 * e4 / 64.0 - 0.01953125 /*5.0 / 256.0*/ * e6);
    v2 = 0.375 /*3.0 / 8.0*/ * (e2 - e4 / 4.0 + 0.1171875 /*15.0 / 128.0*/ * e6);
    v3 = 0.05859375 /*15.0 / 256.0*/ * (e4 + 0.75 /*3.0 / 4.0*/ * e6);
    v4 = meters2miles (equRadius);
    md = v4 * (v1 * lat - v2 * Math.sin (lat * 2) + v3 * Math.sin (lat * 4));

    return md;
}

function meters2miles (meters)
{
    return meters / 1852.0;
}

function hypoLen (cat1, cat2)
{
    return Math.sqrt (cat1 * cat1 + cat2 * cat2);
}

function miles2radian (miles)
{
    return miles * 2.90888208665721596153703703703e-4;
}
    
function radian2miles (rad)
{
    return rad * 3437.7467707849392526107818606515;
}
    
function miles2degree (miles)
{
    return miles * 1.66666666666666666666666666666e-2;
}

function degree2miles (deg)
{
    return deg * 60.0;
}
    
function deg2rad (value)
{
    return Math.PI * value / 180.0;
}

function rad2deg (value)
{
    return 180.0 / Math.PI * value;
}

function isValidRange (range)
{
    return range >= 0.0 && range < 6378137.0 * (Math.PI + Math.PI);
}

function normalizeLat (lat)
{
    while (lat < - Math.PI * 0.5)
        lat = - Math.PI - lat;
    
    while (lat > Math.PI * 0.5)
        lat = Math.PI - lat;
    
    return lat;
}

function normalizeLon (lon)
{
    while (lon < - Math.PI)
        lon += (Math.PI + Math.PI);
    
    while (lon > Math.PI)
        lon -= (Math.PI + Math.PI);
    
    return lon;
}

function isInvalidGeoValue (value)
{
    return Cary.tools.isNothing (value) || isNaN (value);
}

function checkSegmentRag (begLat, begLon, endLat, endLon, assumeRadians, enablePole)
{
    if (checkGeoPointRange (begLat, begLon, assumeRadians, enablePole))
        return checkGeoPointRange (endLat, endLon, assumeRadians, enablePole);
    else
        return false;
}

function checkBegPointCourseDist (begLat, begLon, bearing, range, assumeRadians, enablePole)
{
    if (!checkGeoPointRange (begLat, begLon, assumeRadians, enablePole))
        return false;

    if (assumeRadians)
    {
        if (wrongBearing (bearing))
            return false;
    }
    else
    {
        if (wrongBearingDeg (bearing))
            return false;
    }

    return !wrongRange (range);
}

function isZero (value)
{
    return Math.abs (value) < 1.0E-7;
}
    
function isPole (lat, assumeRadians)
{
    return (lat > 0.0 ? 
            isZero (lat - (assumeRadians ? Math.PI * 0.5 : 90.0)) :
            isZero (lat - (assumeRadians ? - Math.PI * 0.5 : - 90.0)));
}

function wrongLat (val)
{
    return isInvalidGeoValue (val) || val < - Math.PI * 0.5 || val > Math.PI * 0.5;
}

function wrongLon (val)
{
    return isInvalidGeoValue (val) || val < - Math.PI || val > Math.PI;
}

function wrongLatDeg (val)
{
    return isInvalidGeoValue (val) || val < - 90.0 || val > 90.0;
}

function wrongLonDeg (val)
{
    return isInvalidGeoValue (val) || val < - 180.0 || val > 180.0;
}

function wrongBearing (val)
{
    return val < 0.0 || val >= (Math.PI + Math.PI);
}

function wrongBearingDeg (val)
{
    return val < 0.0 || val >= 360.0;
}

function wrongRange (range)
{
    return isInvalidGeoValue (range) || range < 0.0;
}

function checkGeoPointRange (lat, lon, assumeRadians, enablePole)
{
    if (!enablePole && isPole (lat, assumeRadians))
        return false;

    if (assumeRadians)
    {
        if (wrongLat (lat))
            return false;

        if (wrongLon (lon))
            return false;
    }
    else
    {
        if (wrongLatDeg (lat))
            return false;

        if (wrongLonDeg (lon))
            return false;
    }

    return true;
}

function isEqual (val1, val2)
{
    return Math.abs (val1 - val2) < 1.0E-7;
}

function checkBearing (bearing)
{
    while (bearing < 0.0)
        bearing += (Math.PI + Math.PI);
    
    return bearing;
}

function turnBearing (bearing)
{
    bearing = (bearing > Math.PI) ? bearing - Math.PI : bearing + Math.PI;
    
    return normalizeBearing (bearing);
}

function normalizeBearing (bearing)
{
    while (bearing < 0.0)
        bearing += (Math.PI + Math.PI);
    
    while (bearing >= (Math.PI + Math.PI))
        bearing -= (Math.PI + Math.PI);
    
    return bearing;
}

Cary.geo.calcGCRangeAndBearing = function (begLat, begLon, endLat, endLon, datum)
{
    var range      = 0.0;
    var begBearing = 0.0;
    var endBearing = 0.0;
    
    begLat = deg2rad (begLat);
    begLon = deg2rad (begLon);
    endLat = deg2rad (endLat);
    endLon = deg2rad (endLon);
    
    if (Cary.tools.isNothing (datum))
        datum = 1;

    if (isInvalidGeoValue (begLat) || isInvalidGeoValue (begLon) || isInvalidGeoValue (endLat) || isInvalidGeoValue (endLon) ||
        Math.abs (begLat) > 10000.0 || Math.abs (begLon) > 10000.0 || Math.abs (endLat) > 10000.0 || Math.abs (endLon) > 10000.)
        return null;
    
    begLat = normalizeLat (begLat);
    endLat = normalizeLat (endLat);
    begLon = normalizeLon (begLon);
    endLon = normalizeLon (endLon);

    if (!checkSegmentRag (begLat, begLon, endLat, endLon, true, false))
        return null;

    // If both points are the same we cannot calculate as soon begin course as end one. In this case we return zero 
    // distance and zero course
    if (isEqual (begLat, endLat) && isEqual (begLon, endLon))
        return { range: 0.0, bearing: 0.0, endBearing: 0.0 };

    // Calculation block
    // This is a translation of the Fortran routine INVER1 found in the
    // INVERS3D program at:
    // ftp://ftp.ngs.noaa.gov/pub/pcsoft/for_inv.3d/source/invers3d.for
    // The ton most of variables used... (exclude args and global definitions)
    var flattening;
    var c           = 0.0;
    var c_value_1   = 0.0;
    var c_value_2   = 0.0;
    var c2a         = 0.0;
    var cosine_of_x = 0.0;
    var cy          = 0.0;
    var cz          = 0.0;
    var d           = 0.0;
    var e           = 0.0;
    var r_value     = 0.0;
    var s           = 0.0;
    var s_value_1   = 0.0;
    var sa          = 0.0;
    var sine_of_x   = 0.0;
    var sy          = 0.0;
    var tangent_1   = 0.0;
    var tangent_2   = 0.0;
    var x           = 0.0;
    var y           = 0.0;
    var prev_d      = 1.0E300;

    flattening = 3.35281066474751169502944198282e-3; // WGS84

    r_value = 1.0 - flattening;
    tangent_1 = r_value * Math.tan( begLat ); //( r_value * Math.sin( begLat ) ) / Math.cos( begLat );
    tangent_2 = r_value * Math.tan( endLat ); //( r_value * Math.sin( endLat ) ) / Math.cos( endLat );
    c_value_1 = 1.0 / Math.sqrt( ( tangent_1 * tangent_1 ) + 1.0 );
    s_value_1 = c_value_1 * tangent_1;
    c_value_2 = 1.0 / Math.sqrt( ( tangent_2 * tangent_2 ) + 1.0 );
    s = c_value_1 * c_value_2;

    endBearing = s * tangent_2; // backward_azimuth
    begBearing = endBearing * tangent_1;

    x = endLon - begLon;

    do
    {
       sine_of_x   = Math.sin( x );
       cosine_of_x = Math.cos( x );
       tangent_1 = c_value_2 * sine_of_x;
       tangent_2 = endBearing - ( s_value_1 * c_value_2 * cosine_of_x );
       sy = Math.sqrt( ( tangent_1 * tangent_1 ) + ( tangent_2 * tangent_2 ) );
       cy = ( s * cosine_of_x ) + begBearing;
       y = Math.atan2( sy, cy );
       sa = ( s * sine_of_x ) / sy;
       c2a = ( (-sa) * sa ) + 1.0;
       cz = begBearing + begBearing;

       if ( c2a > 0.0 )
       {
          cz = ( (-cz) / c2a ) + cy;
       }

       e = ( cz * cz * 2.0 ) - 1.0;
       c = ( ( ( ( ( -3.0 * c2a ) + 4.0 ) * flattening ) + 4.0 ) * c2a * flattening ) / 16.0;

       prev_d = d;

       d = x;
       x = ( ( ( ( e * cy * c ) + cz ) * sy * c ) + y ) * sa;
       x = ( ( 1.0 - c ) * x * flattening ) + endLon - begLon;
    }
    while (!isEqual (prev_d, x) && !isEqual (d, x));

     // First condition is required to eliminate the recycling

    begBearing = Math.atan2( tangent_1, tangent_2 );
    endBearing = Math.atan2( c_value_1 * sine_of_x, ( (endBearing * cosine_of_x ) - ( s_value_1 * c_value_2 ) ) ) + Math.PI;

    x = Math.sqrt( ( ( ( 1.0 / ( r_value * r_value ) ) - 1 ) * c2a ) + 1.0 ) + 1.0;
    x = ( x - 2.0 ) / x;
    c = 1.0 - x;
    c = ( ( ( x * x ) * 0.25 ) + 1.0 ) / c;
    d = ( ( 0.375 * ( x * x ) ) - 1.0 ) * x;
    x = x * cy;

    s = ( 1.0 - e ) - e;

    var ter1 = 0.0;
    var ter2 = 0.0;
    var ter3 = 0.0;
    var ter4 = 0.0;
    var ter5 = 0.0;

    ter1 = ( sy * sy * 4.0 ) - 3.0;
    ter2 = ( ( s * cz * d ) / 6.0 ) - x;
    ter3 = ter1 * ter2;
    ter4 = ( ( ter3 * d ) * 0.25 ) + cz;
    ter5 = ( ter4 * sy * d ) + y;

    range = ter5 * c * 6378137.0 /* WGS84 equ rad */ * r_value / 1852.0;

    // Check&Turn over to ECDIS
    begBearing = checkBearing (begBearing);
    endBearing = checkBearing (endBearing);
    endBearing = turnBearing (endBearing);

    return { range: range, bearing: rad2deg (begBearing), endBearing: rad2deg (endBearing) };
};

Cary.geo.calcPos = function (begLat, begLon, range, bearing)
{
    var position = google.maps.geometry.spherical.computeOffset (new google.maps.LatLng (begLat, begLon), range * 1852, bearing);
    
    return { endBearing: bearing, lat: position.lat (), lon: position.lng () };
};

Cary.geo.calcGCPos = function (begLat, begLon, range, begBearing, datum)
{
    var endLat     = 0.0;
    var endLon     = 0.0;
    var endBearing = 0.0;
    var flattening;
    var equatorialRadius;

    
    begLat     = deg2rad (begLat);
    begLon     = deg2rad (begLon);
    begBearing = deg2rad (begBearing);
    
    if (Cary.tools.isNothing (datum))
        datum = 1;
    
    if (isInvalidGeoValue (begLat) || isInvalidGeoValue (begLon) || isInvalidGeoValue (range) || isInvalidGeoValue (begBearing))
        return null;

    begLon     = normalizeLon (begLon);
    begBearing = normalizeBearing (begBearing);

    if (!checkBegPointCourseDist (begLat, begLon, begBearing, range, true, false))
        return null;

    // Convert input miles to radians
    //CvMiles2Radian (range);

    // Calculation block
	// Best coincidence with 7Cs Great Circle methods

    // This is a translation of the Fortran routine DIRCT1 found in the
    // FORWRD3D program at:
    // ftp://ftp.ngs.noaa.gov/pub/pcsoft/for_inv.3d/source/forwrd3d.for
    flattening       = 3.35281066474751169502944198282e-3; // WGS84
    equatorialRadius = meters2miles (6378137.0); // WGS84


    var c                                          = 0.0;
    var c2a                                        = 0.0;
    var cosine_of_direction                        = 0.0;
    var cosine_of_y                                = 0.0;
    var cu                                         = 0.0;
    var cz                                         = 0.0;
    var d                                          = 0.0;
    var e                                          = 0.0;
    var direction_in_radians                       = 0.0;
    var r                                          = 0.0;
    var sa                                         = 0.0;
    var sine_of_direction                          = 0.0;
    var sine_of_y                                  = 0.0;
    var su                                         = 0.0;
    var tangent_u                                  = 0.0;
    var term_1                                     = 0.0;
    var term_2                                     = 0.0;
    var term_3                                     = 0.0;
    var x                                          = 0.0;
    var y                                          = 0.0;
    var x_square;

    if (!isValidRange (range))
    {
         return null;
    }
    else if (range < 1.0e-7)
    {
        return { endBearing: rad2deg (begBearing), lat: rad2deg (begLat), lon: rad2deg (begLon) };
    }

    direction_in_radians = begBearing;

    r = 1.0 - flattening;

    tangent_u = r * Math.tan( begLat ); // ( r * Math.sin( begLat ) ) / Math.cos( begLat );

    sine_of_direction = Math.sin( direction_in_radians );

    cosine_of_direction = Math.cos( direction_in_radians );

    if ( cosine_of_direction !== 0.0 )
       endBearing = Math.atan2( tangent_u, cosine_of_direction ) * 2.0;

    cu = 1.0 / Math.sqrt( ( tangent_u * tangent_u ) + 1.0 );
    su = tangent_u * cu;
    sa = cu * sine_of_direction;
    c2a = 1.0 - sa * sa; 
    x = Math.sqrt( ( ( ( 1.0 / (r * r) ) - 1.0 ) * c2a ) + 1.0 ) + 1.0;
    x = ( x - 2.0 ) / x;
    c = 1.0 - x;
    x_square = x * x;
    c = ( ( x_square * 0.25 ) + 1.0 ) / c;
    d = ( ( 0.375 * x_square ) - 1.0 ) * x;

    tangent_u = range * 1852.0 / (r * equatorialRadius * c);

    y = tangent_u;

    do
    {
       sine_of_y = Math.sin( y );
       cosine_of_y = Math.cos( y );
       cz = Math.cos( endBearing + y );
       e = ( cz * cz * 2.0 ) - 1.0;
       c = y;
       x = e * cosine_of_y;
       y = ( e + e ) - 1.0;

       term_1 = ( sine_of_y * sine_of_y * 4.0 ) - 3.0;
       term_2 = ( ( term_1 * y * cz * d ) / 6 ) + x;
       term_3 = ( ( term_2 * d ) * 0.25 ) - cz;
       y = ( term_3 * sine_of_y * d ) + tangent_u;
    }
    while (!isEqual (y, c));

    endBearing = ( cu * cosine_of_y * cosine_of_direction ) - ( su * sine_of_y );

    c = r * hypoLen (sa, endBearing);
    d = ( su * cosine_of_y ) + ( cu * sine_of_y * cosine_of_direction );

    endLat = Math.atan2( d, c );

    c = ( cu * cosine_of_y ) - ( su * sine_of_y * cosine_of_direction );
    x = Math.atan2( sine_of_y * sine_of_direction, c );
    c = ( ( ( ( ( -3.0 * c2a ) + 4.0 ) * flattening ) + 4.0 ) * c2a * flattening ) / 16;
    d = ( ( ( ( e * cosine_of_y * c ) + cz ) * sine_of_y * c ) + y ) * sa;

    endLon = ( begLon + x ) - ( ( 1.0 - c ) * d * flattening );

    endBearing = Math.atan2( sa, endBearing ) + Math.PI;

    endBearing = turnBearing (endBearing);
    //endLon     = checkLongitude (endLon);

    return { endBearing: rad2deg (endBearing), lat: rad2deg (endLat), lon: rad2deg (endLon) };
};

function calcLatEquationRoot (eccentricity, begLat, dNorhing, scaledEquRadius, precision)
{
    var step = 0.001;
    var begPhi;
    var endPhi;
    var midPhi;
    var begValue;
    var midValue;
    var endValue;
    var value = dNorhing / scaledEquRadius;

    // Search for interval range
    begPhi   = begLat - step;
    begValue = calcDeltaPhi (eccentricity, begLat, begPhi);
    endPhi   = begLat + step;
    endValue = calcDeltaPhi (eccentricity, begLat, endPhi);

    if (endValue >= value && begValue <= value)
    {
        // Range is found - no some actions needed
    }
    else if (endValue <= value && begValue >= value)
    {
        // Range is found but must be exachanged
        var gvTemp = begPhi;

        begPhi = endPhi;
        endPhi = gvTemp;
    }
    else if (endValue > begValue && endValue > value)
    {
        // Shift begPhi down until this is great than value
        do
        {
            endPhi   = begPhi;
            begPhi  -= step; 
            endValue = begValue;
            begValue = calcDeltaPhi (eccentricity, begLat, begPhi);
            step    += step;
        }
        while (begValue > value);
    }
    else
    {
        // Shift endPhi upper until this is less than value
        do
        {
            begPhi   = endPhi;
            endPhi  += step; 
            begValue = endValue;
            endValue = calcDeltaPhi (eccentricity, begLat, endPhi);
            step    += step;
        }
        while (endValue < value);
    }

    // Range are found - start linear interpolating...
    do
    {
        midPhi   = begPhi + 
                     (endPhi - begPhi) * (value - begValue) / (endValue - begValue);
        midValue = calcDeltaPhi (eccentricity, begLat, midPhi);

        // Change range...
        if (midValue >= value)
        {
            endPhi   = midPhi;
            endValue = midValue;
        }
        else
        {
            begPhi   = midPhi;
            begValue = midValue;
        }
    }
    while (Math.abs (midValue - value) > precision);

    return midPhi;
}

function internalCalcRLPos (eccentricity, equatorialRadius, begLat, begLon, range, bearing, precision)                                               
{
    var endLat;
    var endLon;
    var scaleCoef       = Math.cos (begLat) / Math.sqrt (1.0 - square (eccentricity * Math.sin (begLat)));
    var scaledEquRadius = scaleCoef * equatorialRadius;
    var dNorthing       = range * Math.cos (bearing);
    var dEasting        = range * Math.sin (bearing);

    endLat = calcLatEquationRoot (eccentricity, begLat, dNorthing, scaledEquRadius, precision);
    endLon = begLon + dEasting / scaledEquRadius;

    // Recalculate scale coefficient for new latitude and repeat...
    scaleCoef       = Math.cos ((begLat + endLat) * 0.5) /
                      Math.sqrt (1.0 - square (eccentricity * Math.sin ((begLat + endLat) * 0.5)));
    scaledEquRadius = scaleCoef * equatorialRadius;
    endLat          = calcLatEquationRoot (eccentricity, begLat, dNorthing, scaledEquRadius, precision);
    endLon          = begLon + dEasting / scaledEquRadius;
    
    return { lat: endLat, lon: endLon };
}

function internalCalcRLRngAndBrg (eccentricity, equatorialRadius, begLat, endLat, westLongDiff, eastLongDiff)
{
    var range;
    var bearing;
    var twoPi           = Math.PI * 2;
    var westLongDiffPos = westLongDiff < 0.0 ? westLongDiff + twoPi : westLongDiff;
    var eastLongDiffPos = eastLongDiff < 0.0 ? eastLongDiff + twoPi : eastLongDiff;
    var middleLat       = (begLat + endLat) * 0.5;
    var scaleCoef       = Math.cos (middleLat) / Math.sqrt (1.0 - square (eccentricity * Math.sin (middleLat)));
    var scaledEquRadius = scaleCoef * equatorialRadius;
    var deltaPhi        = calcDeltaPhi (eccentricity, begLat, endLat);
    var dEasting        = scaledEquRadius * (westLongDiffPos < eastLongDiffPos ? westLongDiffPos : eastLongDiffPos);
    var dNorthing       = scaledEquRadius * deltaPhi;

    return { range: hypoLen (dEasting, dNorthing),
             bearing: fmod (Math.atan2 (westLongDiffPos < eastLongDiffPos ? westLongDiffPos : -eastLongDiffPos, deltaPhi), 
                            Math.PI * 2) };
}

function internalCalcRLRng (eccentricity, equatorialRadius, begLat, endLat, westLongDiff, eastLongDiff)
{
    var middleLat       = (begLat + endLat) * 0.5;
    var scaleCoef       = Math.cos (middleLat) / Math.sqrt (1.0 - square (eccentricity * Math.sin (middleLat)));
    var scaledEquRadius = scaleCoef * equatorialRadius;
    var dEasting        = scaledEquRadius * (westLongDiff < eastLongDiff ? westLongDiff : eastLongDiff);
    var dNorthing       = scaledEquRadius * calcDeltaPhi (eccentricity, begLat, endLat);
             
    return hypoLen (dEasting, dNorthing);
}

Cary.geo.calcRLRangeAndBearing2 = function (begLat, begLon, endLat, endLon, geoid)
{
    var range;
    var bearing;
    
    if (Cary.tools.isNothing (geoid))
        geoid = 1;
    
    begLat = deg2rad (begLat);
    endLat = deg2rad (endLat);
    begLon = deg2rad (begLon);
    endLon = deg2rad (endLon);
    
    if (isInvalidGeoValue (begLat) || isInvalidGeoValue (begLon) || isInvalidGeoValue (endLat) || isInvalidGeoValue (endLon))
        return null;

    if (geoid === 0)
    {
        // Spherical algorythm based on inversed sign for West-East (West positive, East negative)
        begLon = - begLon;
        endLon = - endLon;
    }

    begLon = normalizeLon (begLon);
    endLon = normalizeLon (endLon);

    if (!checkSegmentRag (begLat, begLon, endLat, endLon, true, false))
        return null;

    // Calculation block
    var twoPi        = Math.PI * 2;
    var latDiff      = endLat - begLat;
    var westLongDiff = fmod (endLon - begLon, twoPi);
    var eastLongDiff = fmod (begLon - endLon, twoPi);
    var tangentRate  = Math.tan (endLat * 0.5 + Math.PI * 0.25) / 
                       Math.tan (begLat * 0.5 + Math.PI * 0.25);
    var dirCosine;
    var deltaPhi;

    if (westLongDiff < 0.0)
        westLongDiff += twoPi;
    
    if (eastLongDiff < 0.0)
        eastLongDiff += twoPi;
    
    if (tangentRate <= 0.0)    
        // Attempt to get log of negative or zero
        return null;

    if (geoid === 0)
    {
        // Spherical case
        if (isZero (latDiff))
        {
            // Rhumb line lays on the equator
            dirCosine = Math.cos (begLat); 
            deltaPhi  = 0.0;
        }
        else
        {
            deltaPhi  = Math.log (tangentRate);
            dirCosine = latDiff / deltaPhi;
        }

        // Search the shortest rhumb line
        if (westLongDiff < eastLongDiff)        
        {
            // Westerly rhumb line is the shortest
            bearing = fmod (Math.atan2 (-westLongDiff, deltaPhi), Math.PI * 2);
            range   = radian2miles (hypoLen (dirCosine * westLongDiff, latDiff));
        }
        else
        {
            // Easterly rhumb line is the shortest
            bearing = fmod (atan2 (eastLongDiff, deltaPhi), Math.PI * 2);
            range   = radian2miles (hypoLen (dirCosine * eastLongDiff, latDiff));
        }
    }
    else
    {
        // Use known ellipsoid
        var spitDistanceLeft;
        var stepDistance     = 10.0;
        var precision        = 1.0E-10;
        var flattening       = 3.35281066474751169502944198282e-3; // WGS84
        var equatorialRadius = meters2miles (6378137.0); // WGS84
        var eccentricity     = Math.sqrt (flattening * 2 - square (flattening));
        var rangeUltimate    = 0.0;
        var bearingUltimate;
        var result           = internalCalcRLRngAndBrg (eccentricity, equatorialRadius, begLat, endLat, westLongDiff, eastLongDiff);

        if (result === null)
            return null;

        bearing = result.bearing;
        range   = result.range;

        bearingUltimate  = bearing;
        spitDistanceLeft = range > stepDistance;

        while (spitDistanceLeft)
        {
            // Distance too big - must be splitted...
            var midLat;
            var midLon;
            var midBearing;
            var ratio;
            var result;

            // One step by elementary step distance...
            result = internalCalcRLPos (eccentricity, equatorialRadius, begLat,  begLon, stepDistance, bearingUltimate, precision);
            
            if (result === null)
                return null;
            
            midLat = result.lat;
            midLon = result.lon;

            // Calc distance for rest of distance (this may be splitted too...)
            result = internalCalcRLRngAndBrg (eccentricity, equatorialRadius, midLat, endLat, 
                                              fmod (endLon - midLon, Math.PI * 2), 
                                              fmod (midLon - endLon, Math.PI * 2));

            if (result === null)
                return null;

            midBearing = result.bearing;
            range      = result.range;

            begLat           = midLat;
            begLon           = midLon;
            rangeUltimate   += stepDistance;
            ratio	     = (rangeUltimate === 0.0) ? 1.0 : range / rangeUltimate;
            bearingUltimate  = bearing * (1.0 - ratio) + midBearing * ratio;
            spitDistanceLeft = range > stepDistance;

            if (!spitDistanceLeft)
            {
                range  += rangeUltimate;
                bearing = bearingUltimate;
            }
        }
    }

    while (bearing < 0.0)
        bearing += Math.PI * 2;
    
    return { bearing: rad2deg (bearing), range: range };
};

Cary.geo.calcRLRangeAndBearing = function (begLat, begLon, endLat, endLon, geoid)
{
    var bearing = 0.0;
    var range   = 0.0;
    var latDiff;
    var lonDiff;
    var eccentricity;
    var meridionalDiff;
    var meridionalRangeDiff;
    var flattening       = 3.35281066474751169502944198282e-3; // WGS84
    var equatorialRadius = 6378137.0;                          // WGS84, meters
    
    if (Cary.tools.isNothing (geoid))
        geoid = 1;
    
    if (isInvalidGeoValue (begLat) || isInvalidGeoValue (begLon) || isInvalidGeoValue (endLat) || isInvalidGeoValue (endLon) ||
        Math.abs (begLat) > 10000.0 || Math.abs (begLon) > 10000.0 || Math.abs (endLat) > 10000.0 || Math.abs (endLon) > 10000.0)
        return null;
    
    begLat = normalizeLat (deg2rad (begLat));
    begLon = normalizeLon (deg2rad (begLon));
    endLat = normalizeLat (deg2rad (endLat));
    endLon = normalizeLon (deg2rad (endLon));

    // Calculate difference in latitude and longitude. Beware wrap round in longitude
    lonDiff = endLon - begLon;

    if (lonDiff <= - Math.PI)
        lonDiff += Math.PI * 2;
    else if (lonDiff > Math.PI)
        lonDiff -= Math.PI * 2;

    latDiff = endLat - begLat;

    eccentricity = Math.sqrt (flattening + flattening - flattening * flattening);

    // Test special case of same meridian
    if (Math.abs (latDiff) < 1.0E-10)
    {
        var gvPartial = eccentricity * Math.sin (endLat);
		
        bearing = lonDiff > 0.0 ? 90.0 : 270.0;
	range   = Math.abs (meters2miles (equatorialRadius) * lonDiff * 
                             Math.cos (endLat) / Math.sqrt (1.0 - gvPartial * gvPartial));

        return { bearing: rad2deg (bearing), range: range };
    }

    // Special case of parallel sailings
    if (Math.abs (lonDiff) < 1.0E-10)
    {
        var meridionalDist = calcMeridionalDist (endLat, eccentricity, equatorialRadius) -
                             calcMeridionalDist (begLat, eccentricity, equatorialRadius);
		
        range   = Math.abs (meridionalDist);
	bearing = latDiff > 0.0 ? 0.0 : Math.PI;

        return { bearing: rad2deg (bearing), range: range };
    }	

    // General case
    meridionalDiff      = meridionalPart (endLat, eccentricity) - meridionalPart (begLat, eccentricity);
    meridionalRangeDiff = calcMeridionalDist (endLat, eccentricity, equatorialRadius) -
                          calcMeridionalDist (begLat, eccentricity, equatorialRadius);
    bearing             = normalizeBearing (Math.atan2 (lonDiff, meridionalDiff));
    range               = rad2deg (meridionalRangeDiff) / Math.cos (bearing);

    return { bearing: rad2deg (bearing), range: range };
};

Cary.geo.calcRoughRange = function (lat1, lon1, lat2, lon2)
{
    var coef     = Math.PI / 180.0;
    var northing = Math.abs (lat1 - lat2);
    var easting  = Math.abs (lon1 - lon2) * Math.cos (Math.abs (lat1 + lat2) * coef * 0.5);

    return Math.sqrt (northing * northing + easting * easting) * 60.0;
};

function calcBrgDifference (brg1, brg2)
{
    var difference = Math.abs (brg1 - brg2);
    
    while (difference > 360)
        difference -= 360;
    
    while (difference < 0)
        difference += 360;
    
    if (difference > 180)
        difference = 360 - difference;
    
    return difference;
}
Cary.maps = { overlayMaps: {}, baseMaps: { predefinedTileProviders: {} } };

// Base map support

Cary.maps.baseMaps.StandardMapType = function (name, typeID, flag)
{
    this.name   = name;
    this.typeID = typeID;
    
    if (!flag)
        this.flag = null;
    else
        this.flag = flag;
};

Cary.maps.baseMaps.StandardMapType.prototype.getName = function ()
{
    return this.name;
};

Cary.maps.baseMaps.CustomMapType = function (name, getTileUrl, flag)
{
    this.options = { getTileUrl: getTileUrl, tileSize: new google.maps.Size (256, 256), maxZoom: 18, name: name };
    this.mapType = new google.maps.ImageMapType (this.options);
    this.typeID  = name;
    
    if (!flag)
        this.flag = null;
    else
        this.flag = flag;
};

Cary.maps.baseMaps.CustomMapType.prototype.getName = function ()
{
    return this.options.name;
};

Cary.maps.baseMaps.addToMap = function (map, mask)
{
    Cary.maps.baseMaps.predefinedMaps.forEach (function (baseMap)
                                               {
                                                   if (baseMap instanceof Cary.maps.baseMaps.CustomMapType && baseMap.flag !== null && (mask & baseMap.flag) !== 0)
                                                       baseMap.addToMap (Cary.checkMap (map));
                                               });
};

Cary.maps.baseMaps.CustomMapType.prototype.addToMap = function (map)
{
    Cary.checkMap (map).mapTypes.set (this.typeID, this.mapType);
};

Cary.maps.baseMaps.predefinedTileProviders.getNavionicsTile = function (coord, zoom)
{
    var X   = coord.x % (1 << zoom);  // wrap
    var url = //"http://tiles.openseamap.org/seamark/" + zoom + "/" + X + "/" + coord.y + ".png";
              //'http://navchannel.com/fm/NavionicsTests/getnavtile4.php?z=' + zoom.toString () + '&x=' + coord.x.toString () + '&y=' + coord.y.toString ();
              'http://navchannel.com/fm/temp/getnavtile2.php?z=' + zoom.toString () + '&x=' + coord.x.toString () + '&y=' + coord.y.toString ();

    return url;
};

Cary.maps.baseMaps.predefinedTileProviders.getOpenStreetTile = function (coord, zoom)
{
    var X   = coord.x % (1 << zoom);  // wrap
    var url = 'http://tile.osm.org/' + zoom.toString () + '/' + X.toString () + '/' + coord.y.toString () + '.png';

    return url;
};

Cary.maps.baseMaps.predefinedTileProviders.createSentinel2GTF = function ()
{
    return Cary.maps.baseMaps.predefinedTileProviders.createOpenWeatherTileUrlFunction ('s2');
};

Cary.maps.baseMaps.predefinedTileProviders.createLandsat8GTF = function ()
{
    return Cary.maps.baseMaps.predefinedTileProviders.createOpenWeatherTileUrlFunction ('l8');
};

Cary.maps.baseMaps.predefinedTileProviders.createOpenWeatherTileUrlFunction = function (prefix)
{
    return function (coord, zoom)
           {
               var X   = coord.x % (1 << zoom);  // wrap
               var url = 'http://sat.owm.io/sql/' + zoom.toString () + '/' + X.toString () + '/' + coord.y.toString () + '?order=last&from=' + prefix + 
                         '&APPID=1149c92adf9c8f93227ee161960005a9';
//alert(url);
               return url;
           };
};

Cary.maps.baseMaps.predefinedTileProviders.createScanExTileUrlFunction = function ()
{
    return function (coord, zoom)
           {
               var X   = coord.x % (1 << zoom);  // wrap
               var url = 'http://geomixer.scanex.ru/TileSender.ashx?ModeKey=tile&ftc=osm&x=' + X.toString () + '&y=' + coord.y.toString () + 
                         '&z=' + zoom.toString () + 
                         '&srs=3857&LayerName=RCAF64ECA6B32F437CB6AC72B5E6F85B97:132152&key=mm6UnkKa4BVxRa6YxDVxyYch5SeuT0VlGi82zJr9MhZ4XUGSOORqzgozbX5uByvl61AInDA4N0znBdLMEBmwF1ANUlUwG0XNyARpq0K9Wis%3D';

               return url;
           };
};

Cary.maps.baseMaps.RoadMap    = 1;
Cary.maps.baseMaps.Terrain    = 2;
Cary.maps.baseMaps.Satellite  = 4;
Cary.maps.baseMaps.Hybrid     = 8;
Cary.maps.baseMaps.OpenStreet = 16;
Cary.maps.baseMaps.Navionics  = 32;
Cary.maps.baseMaps.Sentinel2  = 64;
Cary.maps.baseMaps.Landsat8   = 128;
Cary.maps.baseMaps.CustomMap  = 256;
Cary.maps.baseMaps.ScanEx     = 512;

Cary.maps.baseMaps.AllMaps    = 0xFFFF;

Cary.maps.baseMaps.predefinedMaps = [new Cary.maps.baseMaps.StandardMapType ('Roadmap', google.maps.MapTypeId.ROADMAP, Cary.maps.baseMaps.RoadMap),
                                     new Cary.maps.baseMaps.StandardMapType ('Terrain', google.maps.MapTypeId.TERRAIN, Cary.maps.baseMaps.Terrain),
                                     new Cary.maps.baseMaps.StandardMapType ('Satellite', google.maps.MapTypeId.SATELLITE, Cary.maps.baseMaps.Satellite),
                                     new Cary.maps.baseMaps.StandardMapType ('Hybrid', google.maps.MapTypeId.HYBRID, Cary.maps.baseMaps.Hybrid),
                                     new Cary.maps.baseMaps.CustomMapType ('Navionics', Cary.maps.baseMaps.predefinedTileProviders.getNavionicsTile, Cary.maps.baseMaps.Navionics),
                                     new Cary.maps.baseMaps.CustomMapType ('OpenStreet', Cary.maps.baseMaps.predefinedTileProviders.getOpenStreetTile, Cary.maps.baseMaps.OpenStreet),
                                     new Cary.maps.baseMaps.CustomMapType ('Sentinel-2', Cary.maps.baseMaps.predefinedTileProviders.createSentinel2GTF (), Cary.maps.baseMaps.Sentinel2),
                                     new Cary.maps.baseMaps.CustomMapType ('Landsat 8', Cary.maps.baseMaps.predefinedTileProviders.createLandsat8GTF (), Cary.maps.baseMaps.Landsat8),
                                     new Cary.maps.baseMaps.CustomMapType ('ScanEx (demo)', Cary.maps.baseMaps.predefinedTileProviders.createScanExTileUrlFunction (), Cary.maps.baseMaps.ScanEx)];

Cary.maps.baseMaps.getBaseMapIndex = function (flag)
{
    var result = -1;
    var i;
    
    for (i = 0; i < Cary.maps.baseMaps.predefinedMaps.length; ++ i)
    {
        if (Cary.maps.baseMaps.predefinedMaps [i].flag === flag)
        {
            result = i; break;
        }
    }
    
    return result;
};

Cary.maps.baseMaps.select = function (map, index)
{
    Cary.checkMap (map).setMapTypeId (Cary.maps.baseMaps.predefinedMaps [index].typeID);
};

// Overlay maps support
Cary.maps.overlayMaps.CustomOverlayMapType = function (name, getTileUrl, layer, opacity)
{
    this.tileSize   = new google.maps.Size (256, 256);
    this.getTileUrl = getTileUrl;
    this.name       = name;
    this.layer      = layer ? layer : null;
    this.opacity    = Cary.tools.isNothing (opacity) ? null : opacity.toFixed (1);
};

Cary.maps.overlayMaps.CustomOverlayMapType.prototype.getTile = function (coord, zoom, ownerDocument)
{
    var img = ownerDocument.createElement('img');

    img.src          = this.getTileUrl (coord, zoom);
    img.style.width  = this.tileSize.width + 'px';
    img.style.height = this.tileSize.height + 'px';
    
    if (this.opacity)
        img.style.opacity = this.opacity;
    
    return img;
};

Cary.maps.overlayMaps.getOpenSeaTileUrl = function (coord, zoom)
{
    var X   = coord.x % (1 << zoom);  // wrap
    var url = "http://tiles.openseamap.org/seamark/" + zoom + "/" + X + "/" + coord.y + ".png";

    return url;
};

Cary.maps.overlayMaps.CustomUpdatableOverlayMapType = function (name, getTileUrl, layer)
{
    this.tiles = [];
    
    Cary.maps.overlayMaps.CustomOverlayMapType.apply (this, arguments);
};

Cary.maps.overlayMaps.CustomUpdatableOverlayMapType.prototype = Object.create (Cary.maps.overlayMaps.CustomOverlayMapType.prototype);

Cary.maps.overlayMaps.CustomUpdatableOverlayMapType.prototype.getTile = function (coord, zoom, ownerDocument)
{
    var img = Cary.maps.overlayMaps.CustomOverlayMapType.prototype.getTile.apply (this, arguments);

    this.tiles.push ({ img: img, coord: coord, zoom: zoom });
    
    return img;
};

Cary.maps.overlayMaps.CustomUpdatableOverlayMapType.prototype.releaseTile = function (node)
{
    var i;
    
    for (i = 0; i < this.tiles.length; ++ i)
    {
        if (this.tiles [i].img === node)
        {
            this.tiles.splice (i, 1); break;
        }
    }
};

Cary.maps.overlayMaps.CustomUpdatableOverlayMapType.prototype.updateTiles = function ()
{
    this.tiles.forEach (function (tile)
                        {
                            tile.img.src = this.getTileUrl (tile.coord, tile.zoom, document);
                        }, this);
};

Cary.maps.overlayMaps.Layers = {};

Cary.maps.overlayMaps.Layers.OpenSea                  = 1;
Cary.maps.overlayMaps.Layers.OpenWeatherTemp          = 2;
Cary.maps.overlayMaps.Layers.OpenWeatherPrecipitation = 4;
Cary.maps.overlayMaps.Layers.OpenWeatherWind          = 8;
Cary.maps.overlayMaps.Layers.OpenWeatherPressure      = 16;
Cary.maps.overlayMaps.Layers.OpenWeatherClouds        = 32;
Cary.maps.overlayMaps.Layers.AISTargetsMT             = 64;
Cary.maps.overlayMaps.Layers.ScanExSentinel           = 128;

Cary.maps.overlayMaps.createScanExSentinelTileUrlFunc = Cary.maps.baseMaps.predefinedTileProviders.createScanExTileUrlFunction ();

Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc = function (prefix)
{
    return function (coord, zoom)
           {
               var X   = coord.x % (1 << zoom);  // wrap
               var url = 'http://tile.openweathermap.org/map/' + prefix + '_new/' + zoom.toString () + '/' + X.toString () + '/' + coord.y.toString () + '.png?appid=1149c92adf9c8f93227ee161960005a9';
               
               return url;
           };
};

Cary.maps.overlayMaps.getAISTargetMTTileUrl = function (coord, zoom)
{
    var X   = coord.x % (1 << zoom);  // wrap
    var url = 'https://tiles.marinetraffic.com/ais_helpers/shiptilesingle.aspx?output=png&sat=1&grouping=shiptype&tile_size=256&legends=1&zoom=' + zoom + '&X=' + X + '&Y=' + coord.y + '&tm=' +
              Cary.tools.time ();

    return url;
};

Cary.maps.overlayMaps.getOverlayIndex = function (flag)
{
    var result = -1;
    var i;
    
    for (i = 0; i < Cary.maps.overlayMaps.predefinedMaps.length; ++ i)
    {
        if (Cary.maps.overlayMaps.predefinedMaps [i].layer === flag)
        {
            result = i; break;
        }
    }
    
    return result;
};

Cary.maps.overlayMaps.aisTargetLayer = new Cary.maps.overlayMaps.CustomUpdatableOverlayMapType ('AIS targets (MarineTraffic)', Cary.maps.overlayMaps.getAISTargetMTTileUrl,
                                                                                                Cary.maps.overlayMaps.Layers.AISTargetsMT);
                                                                                                
Cary.maps.overlayMaps.predefinedMaps = [new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenSea', Cary.maps.overlayMaps.getOpenSeaTileUrl, Cary.maps.overlayMaps.Layers.OpenSea),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenWeather/Temperature', Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc ('temp'), 
                                                                                        Cary.maps.overlayMaps.Layers.OpenWeatherTemp),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenWeather/Precipitation',  Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc ('precipitation'), 
                                                                                        Cary.maps.overlayMaps.Layers.OpenWeatherPrecipitation),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenWeather/Wind', Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc ('wind'), 
                                                                                        Cary.maps.overlayMaps.Layers.OpenWeatherWind),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenWeather/Pressure', Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc ('pressure'), 
                                                                                        Cary.maps.overlayMaps.Layers.OpenWeatherPressure),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('OpenWeather/Clouds', Cary.maps.overlayMaps.createOpenWeatherTileUrlFunc ('clouds'), 
                                                                                        Cary.maps.overlayMaps.Layers.OpenWeatherClouds),
                                        new Cary.maps.overlayMaps.CustomOverlayMapType ('ScanEx/Sentinel', Cary.maps.overlayMaps.createScanExSentinelTileUrlFunc, 
                                                                                        Cary.maps.overlayMaps.Layers.ScanExSentinel, 0.6),
                                        Cary.maps.overlayMaps.aisTargetLayer];

Cary.maps.overlayMaps.isOverlayLayerVisible = function (map, index)
{
    var layer = Cary.maps.overlayMaps.predefinedMaps [index];
    var result;
    var mapType;
    var i, count;

    map = Cary.checkMap (map);
    
    for (i = 0, count = map.overlayMapTypes.getLength (), result = false; i < count; ++ i)
    {
        mapType = map.overlayMapTypes.getAt (i);

        if (mapType === layer)
        {
            result = true; break;
        }
    }
    
    return result;
};

Cary.maps.overlayMaps.showOverlayLayer = function (map, index, show)
{
    var layer = Cary.maps.overlayMaps.predefinedMaps [index];

    map = Cary.checkMap (map);
    
    if (typeof (show) === 'undefined')
        show = true;
    
    if (show)
    {
        map.overlayMapTypes.insertAt (0, layer);
    }
    else
    {
        var mapType;
        var i, count;

        for (i = 0, count = map.overlayMapTypes.getLength (); i < count; ++ i)
        {
            mapType = map.overlayMapTypes.getAt (i);

            if (mapType === layer)
            {
                map.overlayMapTypes.removeAt (i); break;
            }
        }
    }
};

Cary.maps.geoToClient = function (map, position)
{
    var projection  = map.getProjection ();
    var posPoint    = new google.maps.Point (0, 0),
        centerPoint = new google.maps.Point (0, 0);
    var center      = map.getCenter ();
    var tileSize    = (1 << map.getZoom ());
    var mapDiv      = map.getDiv ();
    var x,
        y;

    projection.fromLatLngToPoint (position, posPoint);
    projection.fromLatLngToPoint (center, centerPoint);

    x = Number (((posPoint.x - centerPoint.x) * tileSize).toFixed ()) + (mapDiv.clientWidth >> 1) /*- 128*/;
    y = Number (((posPoint.y - centerPoint.y) * tileSize).toFixed ()) + (mapDiv.clientHeight >> 1);

    return new google.maps.Point (x, y);
};

Cary.maps.getBounds = function (points)
{
    var bounds = null;
    
    if (!Cary.tools.isNothing (points) && points.length > 0)
    {
        var point1 = { lat: points [0].lat, lng: points [0].lon };
        var point2 = points.length > 1 ? { lat: points [1].lat, lng: points [1].lon } : point1;
        var i;
        
        bounds = new google.maps.LatLngBounds (point1, point1);
        
        for (i = 1; i < points.length; ++ i)
            bounds.extend ({ lat: points [i].lat, lng: points [i].lon });
    }
    
    return bounds;
};


Cary.controls.pixelProps = ['left', 'top', 'right', 'bottom', 'width', 'height', 'borderWidth', 'borderRadius', 'fontSize', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop',
                            'paddingBottom', 'margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom'];

Cary.controls.setStyles = function (htmlElement, styles)
{
    Cary.controls.pixelProps.forEach (function (property)
                                      {
                                        if (property in styles && typeof (styles [property]) === 'number')
                                            styles [property] = styles [property].toString () + 'px';
                                      });
    
    for (var key in styles)
    {
        if (styles [key] !== null && typeof (styles [key]) !== 'function')
            htmlElement.style [key] = styles [key];
    }
};

Cary.controls.GenericMapControl = function (map, position, options)
{
    this.map       = Cary.checkMap (map);
    this.options   = options;
    this.position  = position;
    this.container = null;
};

Cary.controls.GenericMapControl.prototype = new google.maps.OverlayView ();

Cary.controls.GenericMapControl.prototype.show = function (visible)
{
    if (Cary.tools.isNothing (visible))
        visible = true;
    
    this.setMap (visible ? this.map : null);
};

Cary.controls.GenericMapControl.prototype.delayedShow = function (interval)
{
    var instance = this;
    
    if (Cary.tools.isNothing (interval))
        interval = 200;
    
    setTimeout (function () { instance.show (instance.position); }, interval);
};

Cary.controls.GenericMapControl.prototype.getOption = function (name, defValue)
{
    var result;
    
    if (name in this.options)
        result = this.options [name];
    else
        result = defValue;
    
    return result;
};

Cary.controls.GenericMapControl.prototype.initialize = function ()
{
};

Cary.controls.GenericMapControl.prototype.onAdd = function ()
{
    var styles = 'styles' in this.options ? this.options.styles : {};
    
    this.container = document.createElement ('div');
    
    for (var key in styles)
    {
        if (styles [key] !== null)
            this.container.style [key] = styles [key];
    }

    this.initialize ();
    
    this.getPanes ().overlayLayer.appendChild (this.container);
};

Cary.controls.GenericMapControl.prototype.draw = function ()
{
    var projection = this.getProjection ();
    var basePoint  = projection.fromLatLngToDivPixel (this.position);

    this.container.style.left = basePoint.x + 'px';
    this.container.style.top  = basePoint.y + 'px';
};

Cary.controls.GenericMapControl.prototype.onRemove = function ()
{
    this.container.parentNode.removeChild (this.container);

    this.container = null;
};

Cary.controls.GenericMapDomControl = function (map, location, options, className)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    if (Cary.tools.isNothing (className))
        className = null;
    
    this.map       = Cary.checkMap (map);
    this.options   = options;
    this.container = document.createElement ('div');
    this.location  = location;
    
    if (className !== null)
        this.container.className = className;
    
    this.setStyles (options);
    this.initialize ();
    
    this.container.control = this;
    
    this.ctlIndex = this.map.controls [location].push (this.container) - 1;

    this.show ('visible' in options && options.visible);
};

Cary.controls.GenericMapDomControl.prototype.remove = function (map)
{
    var i;

    for (i = 0; i < map.controls [this.location].length; ++ i)
    {
        if (map.controls [this.location].getAt (i) === this.container)
        {
            map.controls [this.location].removeAt (i); break;
        }
    }
};

Cary.controls.GenericMapDomControl.prototype.setStyles = function (styles)
{
    Cary.controls.setStyles (this.container, styles);
};

Cary.controls.GenericMapDomControl.prototype.initialize = function ()
{
};

Cary.controls.GenericMapDomControl.prototype.show = function (visible)
{
    if (Cary.tools.isNothing (visible))
        visible = true;
    
    this.container.style.display = visible ? null : 'none';
};

Cary.controls.GenericMapDomControl.prototype.isVisible = function ()
{
    return this.container.style.display !== 'none';
};
    
Cary.controls.GenericMapDomControl.prototype.setText = function (text)
{
    this.container.innerText = text;
};

Cary.controls.GenericDomControl = function (map, point)
{
    this.map       = Cary.checkMap (map);
    this.parent    = this.map.getDiv ();
    this.point     = point;
    this.container = document.createElement ('div');
    
    this.container.style.left   = Cary.tools.int2pix (point.x);
    this.container.style.top    = Cary.tools.int2pix (point.y);
    this.container.style.zIndex = 500;
    
    this.parent.appendChild (this.container);
};

Cary.controls.GenericDomControl.prototype.close = function ()
{
    if (this.parent.contains (this.container))
        this.parent.removeChild (this.container);
};

Cary.controls.GenericDomControl.prototype.show = function (visible)
{
    this.container.style.display = visible ? null : 'none';
};

Cary.controls.Tag = function (map, position, text, minZoom, styles, zoomToFontSize, zoomToPlacement)
{
    var options = {};
  
    if (Cary.tools.isNothing (zoomToFontSize))
        zoomToFontSize = null;
    
    this.text            = text;
    this.zoomWatchdog    = null;
    this.minZoom         = Cary.tools.isNothing (minZoom) ? 15 : minZoom;
    this.onZoomChanged   = null;
    this.zoomToFontSize  = zoomToFontSize;
    this.zoomToPlacement = zoomToPlacement;
    
    if (!Cary.tools.isNothing (styles))
        options.styles = styles;
    
    Cary.controls.GenericMapControl.apply (this, [map, position, options]);

    this.checkZoomWatchdog ();
};

Cary.controls.Tag.prototype = Object.create (Cary.controls.GenericMapControl.prototype);

Cary.controls.Tag.prototype.checkZoomWatchdog = function ()
{
    var map      = this.getMap ();
    var instance = this;
    
    if (map !== null && this.zoomWatchdog === null)
    {
        this.zoomWatchdog  = google.maps.event.addListener (map, 'zoom_changed', onZoomChanged);
        this.onZoomChanged = onZoomChanged; // Startup call
    }
    
    function onZoomChanged ()
    {
        var zoom    = map.getZoom ();
        var visible = zoom >= instance.minZoom;
        
        instance.container.style.display = visible ? null : 'none';
        
        if (visible)
        {
            if (instance.zoomToFontSize !== null)
                instance.container.style.fontSize = Cary.tools.int2pix (instance.zoomToFontSize (zoom));
            
            if (instance.zoomToPlacement !== null)
            {
                var result = instance.zoomToPlacement (zoom);
                
                for (var key in result)
                    instance.container.style [key] = Cary.tools.int2pix (result [key]);
            }
        }
    }
};

Cary.controls.Tag.prototype.initialize = function ()
{
    this.container.innerText = this.text;
    this.container.className = 'tag';
    
    if (this.onZoomChanged !== null)
        this.onZoomChanged ();
};

Cary.controls.Tag.prototype.setText = function (text)
{
    this.text = text;

    if (this.container !== null)
        this.container.innerText = this.text;
};

Cary.controls.Tag.prototype.getMap = function ()
{
    var map = Cary.controls.GenericMapControl.prototype.getMap.apply (this, arguments);
    
    return Cary.tools.isNothing (map) ? null : map;
};

Cary.controls.Tag.prototype.setMap = function (map)
{
    Cary.controls.GenericMapControl.prototype.setMap.apply (this, arguments);
    
    if (map !== null)
    {
        this.checkZoomWatchdog ();
    }
    else if (this.zoomWatchdog !== null)
    {
        google.maps.event.removeListener (this.zoomWatchdog);
        
        this.zoomWatchdog = null;
    }
};

Cary.controls.MFBalloon = function (map, position, options)
{
    Cary.controls.GenericMapControl.apply (this, arguments);
    
    this.text           = 'text' in options ? options.text : null;
    this.html           = 'html' in options ? options.html : null;
    this.closeable      = 'closeable' in options ? options.closeable : true;
    this.settings       = 'settings' in options ? options.settings : null;
    this.settingsParam  = 'settingsParam' in options ? options.settingsParam : null;
    this.timeout        = 'timeout' in options ? options.timeout : 0;
    this.horOffset      = 'horOffset' in options ? options.horOffset : 0;
    this.verOffset      = 'verOffset' in options ? options.verOffset : 0;
    this.linkDesc       = 'links' in options ? options.links : [];
    this.onClose        = 'onClose' in options ? options.onClose : null;
    this.getMaxWidth    = 'getMaxWidth' in options ? options.getMaxWidth : null;
    this.getMaxHeight   = 'getMaxHeight' in options ? options.getMaxHeight : null;
    this.divWidth       = 'divWidth' in options ? options.divWidth : null;
    this.links          = [];
    this.x              = null;
    this.y              = null;
    this.left           = null;
    this.top            = null;
    this.width          = null;
    this.height         = null;
    this.bounds         = null;
};

Cary.controls.MFBalloon.prototype = Object.create (Cary.controls.GenericMapControl.prototype);

Cary.controls.MFBalloon.prototype.initialize = function ()
{
    var instance = this;

    this.container.className = 'mfBalloon';

    if (this.html)
        this.container.innerHTML = this.html;
    else
        this.container.innerText = this.text;
    
    if (this.closeable)
    {
        var closeIcon = document.createElement ('div');
        
        closeIcon.className = 'closeIcon';
        closeIcon.onclick   = function (event)
                              {
                                  instance.show (false);

                                  if (onClose)
                                      onClose (event);
                              };
        closeIcon.innerText = Cary.symbols.cross; //  '✖';
        closeIcon.className = 'mfCloseIcon';
        
        this.container.appendChild (closeIcon);
    }
    
    if (this.settings)
    {
        var settingsButton = document.createElement ('img');
    
        settingsButton.src       = 'res/settings26.png';
        settingsButton.onclick   = function ()
                                   { 
                                       instance.show (false);
                                       instance.settings (this.owner.settingsParam);
                                   };
        settingsButton.className = 'mfSettingsButton';
        
        this.container.appendChild (settingsButton);
    }
    
    this.linkDesc.forEach (addLink);
    
    function addLink (desc)
    {
        var link = document.createElement ('a');
        
        if ('callback' in desc)
        {
            link.param    = 'param' in desc ? desc.param : null;
            link.callback = desc.callback;
            link.onclick  = function ()
                            {
                                instance.show (false);
                                instance.callback (this.param);
                            };
        }
        else if ('href' in desc)
        {
            link.param    = 'param' in desc ? desc.param : null;
            link.title    = desc.text;
            link.link     = desc.href;
            link.owner    = this;
            link.onclick  = function ()
                            {
                                instance.show (false);
                                
                                //openInternalBrowser ({ title: this.title, link: this.link });
                            };
        }
        else if ('callbackName' in desc && 'param' in desc)
        {
            link.href = 'javascript:MFBalloon.show(false);' + desc.callbackName + '(' + desc.param + ');';
        }
        else
        {
            link.href = null;
        }
        
        if (desc.html)
            link.innerHTML = desc.html;
        else if ('text' in desc)
            link.innerText = desc.text;
        else if ('name' in desc)
            link.innerText = desc.name;
        else
            link.innerText = '';

        link.className     = 'mfLink';
        link.target        = '_blank';
        link.style.cursor  = 'pointer';
        link.style.display = 'block';
        
        instance.container.appendChild (link);
    }
};

Cary.controls.MFBalloon.prototype.setPosition = function (position)
{
    this.position = position;
    
    this.draw ();
};

Cary.controls.MFBalloon.prototype.draw = function ()
{
    var projection = this.getProjection ();
    var northWest  = projection.fromLatLngToDivPixel (this.position);
    var screenNW   = projection.fromLatLngToContainerPixel (this.position);
    var x          = northWest.x + this.horOffset;
    var y          = northWest.y - this.verOffset;
    var southWest;
    var northEast;
    
    this.x      = x;
    this.y      = y;
    this.width  = this.container.clientWidth;
    this.height = this.container.clientHeight;

    if (screenNW.x < this.container.clientWidth)
        this.left = x;
    else
        this.left = x - this.container.clientWidth;

    this.container.style.left = int2pix (this.left);
    
    if (screenNW.y < this.container.clientHeight)
        this.top = y;
    else
        this.top = y - this.container.clientHeight;
    
    this.container.style.top = int2pix (this.top);
        
    southWest = projection.fromDivPixelToLatLng (new google.maps.Point (this.left - 10, this.top + this.height + 10));
    northEast = projection.fromDivPixelToLatLng (new google.maps.Point (this.left + this.width + 10, this.top - 10));
    
    this.bounds = new google.maps.LatLngBounds (southWest, northEast);
    
    div.onclick = function (event)
                  {
                      this.style.zIndex = 1000;

                      if (event)
                          event.cancelBubble = true;
                      else
                          window.event.cancelBubble = true;

                      if ('stopPropagation' in event)
                          event.stopPropagation ();
                  };
                       
     if (this.timeout)
     {
         var object = this;
         
         setTimeout (function () { object.hide (); }, 5000);
     }
};

Cary.controls.MFBalloon.prototype.setText = function (text)
{
    if (this.container !== null)
        this.container.innerText = text;
};

Cary.controls.MFBalloon.prototype.getClientRect = function ()
{
    return this.container === null ? null : this.containe.getBoundingClientRect ();
};

Cary.controls.MFBalloon.prototype.getEstimatedRect = function ()
{
    var overlayProjection = this.getProjection ();
    var result;
    var northWest;
    
    if (overlayProjection === null)
    {
        result = null;
    }
    else
    {
        northWest = overlayProjection.fromLatLngToDivPixel (this.position);

        result = { left: northWest.x + this.horOffset, top: northWest.y, width: 150, height: 25 };
    }
    
    return result;
};

Cary.controls.MFBalloon.prototype.containsPoint = function (x, y)
{
   return (x >=  (this.left - 10)) && (y >= (this.top - 10)) && (x <= (this.left + this.width + 10)) && (y <= (this.top + this.height + 10));
};

Cary.controls.MFBalloon.prototype.bound = function ()
{
    return this.bounds !== null;
};
    
Cary.controls.MFBalloon.prototype.containsPos = function (pos)
{
   return this.bounds && this.bounds.contains (pos);
};

Cary.controls.MapLocker = function (map, initiallyActive, onClick)
{
    var options = { width: '100%', height: '100%', margin: 0, padding: 0, backgroundColor: 'lightgray', left: 0, top: 0, zIndex: 2, opacity: 0.5 };
    
    if (Cary.tools.isNothing (onClick))
        onClick = null;
    
    if (Cary.tools.isNothing (initiallyActive))
        initiallyActive = false;
    
    if (initiallyActive)
        options.visible = true;

    this.onClick = onClick;
    
    Cary.controls.GenericMapDomControl.apply (this, [map, google.maps.ControlPosition.TOP_RIGHT, options]);
};

Cary.controls.MapLocker.prototype = Object.create (Cary.controls.GenericMapDomControl.prototype);

Cary.controls.MapLocker.prototype.initialize = function ()
{
    Cary.controls.GenericMapDomControl.prototype.initialize.apply (this, arguments);
    
    if (this.onClick !== null)
        this.container.onclick = this.onClick;
};

Cary.controls.PosIndicator = function (map, location, options)
{
    var left, top, ctlOptions;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    left = 'left' in options ? options.left : 50;
    top  = 'top' in options ? options.top : 50;

    for (var key in options)
        ctlOptions [key] = options [key];
    
    Cary.controls.GenericMapDomControl.apply (this, [map, location, ctlOptions, 'posIndicator']);
};

Cary.controls.PosIndicator.prototype = Object.create (Cary.controls.GenericMapDomControl.prototype);

Cary.controls.PosIndicator.prototype.setValue = function (lat, lon)
{
    this.setText (Cary.tools.formatLat (lat) + ' ' + Cary.tools.formatLon (lon));
};

Cary.controls.PosIndicator.prototype.onMouseEvent = function (event)
{
    this.setValue (event.latLng.lat (), event.latLng.lng ());
};

Cary.controls.ImgButton = function (map, location, imgSource, options)
{
    var ctlOptions;
    
    this.imgSource = imgSource;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    ctlOptions = { width: 'fit-content', height: 'fit-content', borderStyle: 'solid', borderColor: '#666666', borderRadius: 6, margin: 5, padding: 3, paddingBottom: 1,
                   backgroundColor: '#ccff99', cursor: 'pointer', userSelect: 'none', hiliteColor: '#99aa66', boxShadow: '1px 1px 10px rgba(0, 0, 0, 0.5)' };

    for (var key in options)
        ctlOptions [key] = options [key];
    
    Cary.controls.GenericMapDomControl.apply (this, [map, location, ctlOptions]);
    
    if ('hiliteColor' in ctlOptions)
    {
        var instance = this;
        
        this.hiliteColor           = ctlOptions.hiliteColor;
        this.normalColor           = 'backgroundColor' in ctlOptions ? ctlOptions.backgroundColor : null;
        this.container.onmouseover = function () { instance.container.style.backgroundColor = instance.hiliteColor; };
        this.container.onmouseout  = function () { instance.container.style.backgroundColor = instance.normalColor; };
    }
};

Cary.controls.ImgButton.prototype = Object.create (Cary.controls.GenericMapDomControl.prototype);

Cary.controls.ImgButton.prototype.initialize = function ()
{
    var img = document.createElement ('img');
    
    Cary.controls.PosIndicator.prototype.initialize.apply (this, arguments);
    
    img.src       = this.imgSource;
    img.className = 'imgButton';
    img.draggable = false;
    
    if ('onClick' in this.options)
        img.onclick = this.options.onClick;
    
    this.container.appendChild (img);
};


Cary.controls.Balloon = function (map, options)
{
    var point = {};
    
    if ('text' in options)
    {
        this.text = options.text;
        this.html = null;
    }
    else if ('html' in options)
    {
        this.html = options.html;
        this.text = null;
    }
    else
    {
        this.text = null;
        this.html = null;
    }
        
    this.options   = options;
    this.map       = Cary.checkMap (map);
    this.horOffset = 'horOffset' in options ? options.horOffset : 0;
    this.verOffset = 'verOffset' in options ? options.verOffset : 0;
    
    if ('lat' in options && 'lon' in options)
    {
        var projection = this.map.getProjection ();
        var northWest  = projection.fromLatLngToDivPixel (new google.maps.LatLng (options.lat, options.lon));
        
        point.x = northWest.x + this.horOffset;
        point.y = northWest.y - this.verOffset;
    }
    else if ('x' in options && 'y' in options)
    {
        point.x = options.x + this.horOffset;
        point.y = options.y - this.verOffset;
    }
    
    Cary.controls.GenericDomControl.apply (this, [map, point]);
    
    this.container.className = 'balloon';
    
    if (this.text !== null)
        this.container.innerText = this.text;
    else if (this.html !== null)
        this.container.innerHtml = this.html;
};

Cary.controls.Balloon.prototype = Object.create (Cary.controls.GenericDomControl.prototype);

Cary.controls.Balloon.prototype.setPosition = function (lat, lon)
{
    var position = Cary.maps.geoToClient (this.map, new google.maps.LatLng (lat, lon));
    
    this.container.style.left = Cary.tools.int2pix (position.x + this.horOffset);
    this.container.style.top  = Cary.tools.int2pix (position.y - this.verOffset);
    
    this.checkPosition ();
};

Cary.controls.Balloon.prototype.setDomPosition = function (x, y)
{
    this.container.style.left = Cary.tools.int2pix (x + this.horOffset);
    this.container.style.top  = Cary.tools.int2pix (y - this.verOffset);
    
    this.checkPosition ();
};

Cary.controls.Balloon.prototype.setText = function (text)
{
    this.text = text;
    
    this.container.innerText = text;
    
    this.checkPosition ();
};

Cary.controls.Balloon.prototype.setHtml = function (html)
{
    this.html = html;
    
    this.container.innerHtml = html;
    
    this.checkPosition ();
};

Cary.controls.Balloon.prototype.checkPosition = function (x, y)
{
    var mapDiv = this.map.getDiv ();

    if (Cary.tools.isNothing (x))
        x = parseInt (this.container.style.left);
    
    if (Cary.tools.isNothing (y))
        y = parseInt (this.container.style.top);
    
    if ((x + this.container.clientWidth) > mapDiv.clientWidth)
        this.container.style.left = Cary.tools.int2pix (x - this.horOffset - this.container.clientWidth);
    
    if ((y + this.container.clientHeight) > mapDiv.clientHeight)
        this.container.style.top = Cary.tools.int2pix (y - this.verOffset - this.container.clientHeight);
};

Cary.controls.GMPanel = function (map, location, options)
{
    var ctlOptions;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    ctlOptions = { fontSize: 12, width: 300, height: '95%', borderStyle: 'solid', borderColor: 'black', borderRadius: 4, margin: 10, padding: 3, marginRight: 10, zIndex: 10    ,
                   backgroundColor: 'lightcyan', boxShadow: '1px 1px 10px rgba(0, 0, 0, 0.5)' };

    for (var key in options)
        ctlOptions [key] = options [key];

    this.slidingMode = Cary.controls.GMPanel.slidingMode.NONE;
    this.cover       = null;
    this.options     = options;
    this.activeItem  = null;
    
    Cary.controls.GenericMapDomControl.apply (this, [map, location, ctlOptions]);
    
    this.container.style.zOrder = 500;
};

Cary.controls.GMPanel.slidingMode = { LEFT: 1, RIGHT: 2, NONE: 0 };

Cary.controls.GMPanel.prototype = Object.create (Cary.controls.GenericMapDomControl.prototype);

Cary.controls.GMPanel.prototype.setSlidingMode = function (mode, transitionTime)
{
    this.slidingMode = mode;
    
    if (Cary.tools.isNothing (transitionTime))
        transitionTime = 0.5;
    
    switch (mode)
    {
        case Cary.controls.GMPanel.slidingMode.LEFT:
            this.container.style.left        = '0px';
            this.container.style.marginRight = this.options.width;
            
            break;
            
        case Cary.controls.GMPanel.slidingMode.RIGHT:
            this.container.style.right      = '0px';
            this.container.style.marginLeft = this.options.width;
            
            break;
            
        default:
            break;
    }
    
    this.container.style.transition = transitionTime.toString () + 's';
    this.container.style.display    = null;
    
    this.slideOut ();
};

Cary.controls.GMPanel.prototype.slideIn = function (forceImmediately)
{
    var transition = null;
    
    if (forceImmediately)
    {
        transition = this.container.style.transition;
        
        this.container.style.transition = null;
    }
    
    switch (this.slidingMode)
    {
        case Cary.controls.GMPanel.slidingMode.LEFT:
            this.container.style.left       = '0px';
            this.container.style.marginLeft = '10px'; break;
        
        case Cary.controls.GMPanel.slidingMode.RIGHT:
            this.container.style.right       = '0px';
            this.container.style.marginRight = '10px'; break;
            
        default:
            return;
    }
    
    if (forceImmediately && transition !== null)
        setTimeout (function () { this.container.style.transition = transition; }, 200);
    
    if ('onOpen' in this.options)
        this.options.onOpen (this);
};

Cary.controls.GMPanel.prototype.slideOut = function (forceImmediately)
{
    var hideDistance = Cary.tools.int2pix (- parseInt (this.options.width) - 60);
    var transition   = null;
    
    if (forceImmediately)
    {
        transition = this.container.style.transition;
        
        this.container.style.transition = null;
    }
    
    switch (this.slidingMode)
    {
        case Cary.controls.GMPanel.slidingMode.LEFT:
            this.container.style.marginLeft = hideDistance; break;
        
        case Cary.controls.GMPanel.slidingMode.RIGHT:
            this.container.style.marginRight = hideDistance; break;
            
        default:
            return;
    }
    
    if (forceImmediately && transition !== null)
        setTimeout (function () { this.container.style.transition = transition; }, 200);
    
    if ('onClose' in this.options)
        this.options.onClose (this);
};

Cary.controls.GMPanel.prototype.addSubPanel = function (options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var subPanel = document.createElement ('div');
    
    Cary.controls.setStyles (subPanel, options);
    
    //subPanel.style.display = 'block';
    subPanel.style.width   = '101%';
    
    this.container.appendChild (subPanel);
    
    return subPanel;
};

Cary.controls.GMPanel.prototype.addTitle = function (titleText, options, onClose)
{
    if (Cary.tools.isNothing (options))
        options = { left: 0, right: 0, height: 30, margin: 0, border: 'none', fontSize: 20, borderBottomStyle: 'solid', borderBottomColor: 'lightgray', borderBottomWidth: 1,
                    textAlign: 'center' };
    
    var closeIcon = document.createElement ('div');
    var text      = document.createElement ('div');
    var title     = this.addSubPanel (options);
    var instance  = this;

    closeIcon.style.display         = 'inline';
    closeIcon.style.float           = 'right';
    closeIcon.style.marginRight     = '10px';
    closeIcon.style.lineHeight      = '20px';
    closeIcon.style.backgroundColor = 'transparent';
    closeIcon.style.color           = 'gray';
    closeIcon.style.fontSize        = '30px';
    closeIcon.innerText             = Cary.symbols.toLeft2;
    closeIcon.onclick               = doClose;
    closeIcon.style.cursor          = 'pointer';
    closeIcon.style.userSelection   = 'none';

    text.style.display         = 'inline';
    text.style.float           = 'left';
    text.style.marginRight     = '15px';
    text.style.lineHeight      = '24px';
    text.backgroundColor       = 'transparent';
    text.style.color           = 'black';
    text.style.fontSize        = '20px';
    text.innerText             = titleText;
    text.style.textAlign       = 'right';
    text.style.left            = '50px';
    text.style.width           = '180px';

    title.appendChild (text);
    title.appendChild (closeIcon);
    
    this.lock = function ()
                {
                    closeIcon.style.display = 'none';
                   
                    instance.activeItem.className = Cary.settings.selectedItemClass;
        
                    instance.enable (false);
                };
    
    this.unlock = function ()
                {
                    closeIcon.style.display = null;
                    
                    if (instance.activeItem !== null)
                        instance.activeItem.className = Cary.settings.activeItemClass;
        
                    instance.enable (true);
                    
                    instance.activeItem = null;
                };
    
    function doClose ()
    {
        if (instance.slidingMode === Cary.controls.GMPanel.slidingMode.NONE)
            instance.show (false);
        else
            instance.slideOut ();
        
        if (!Cary.tools.isNothing (onClose))
            onClose ();
    }
};

Cary.controls.GMPanel.prototype.show = function (visible)
{
    if (Cary.tools.isNothing (visible))
        visible = true;
    
    Cary.controls.GenericMapDomControl.prototype.show.apply (this, arguments);

    if (visible)
    {
        if ('onOpen' in this.options)
            this.options.onOpen (this);
    }
    else
    {
        if ('onClose' in this.options)
            this.options.onClose (this);
    }
};

Cary.controls.GMPanel.prototype.addSubMenu = function (options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var subMenu    = document.createElement ('div');
    var openButton = document.createElement ('div');
    var instance   = this;
    
    subMenu.style.width      = '100%';
    subMenu.style.height     = 'height' in options ? options.height : '20px';
    subMenu.style.margin     = '0px';
    subMenu.style.textAlign  = 'left';
    subMenu.style.fontSize   = '15px';
    subMenu.style.padding    = '8px';
    subMenu.style.cursor     = 'pointer';
    subMenu.style.userSelect = 'none';
    subMenu.onclick          = doClick;
    
    subMenu.className = Cary.settings.activeItemClass;
    
    openButton.style.width      = '30px';
    openButton.style.height     = '100%';
    openButton.style.margin     = '0px';
    openButton.style.float      = 'right';
    openButton.style.cursor     = 'pointer';
    openButton.style.fontSize   = '25px';
    openButton.style.lineHeight = '15px';
    openButton.innerText        = Cary.symbols.toRight2;
    openButton.doClick          = doClick;
    
    if ('text' in options)
        subMenu.innerText = options.text;
    
    Cary.controls.setStyles (subMenu, options);
    
    if ('parent' in options)
        options.parent.appendChild (subMenu);
    else
        this.container.appendChild (subMenu);
    
    subMenu.appendChild (openButton);
    
    return subMenu;
    
    function doClick ()
    {
        instance.activeItem = subMenu;
        
        instance.lock ();
        
        if ('onClick' in options)
            options.onClick ();
    }
};

Cary.controls.GMPanel.prototype.initialize = function ()
{
    //this.container.className = 'sliding';
    
    if ('onInit' in this.options)
        this.options.onInit (this);
};

Cary.controls.GMPanel.prototype.enable = function (flag)
{
    if (flag)
    {
        if (this.cover !== null)
        {
            this.container.removeChild (this.cover);
            
            this.cover = null;
        }
    }
    else
    {
        this.cover = document.createElement ('div');

        this.cover.style.position = 'absolute';
        this.cover.style.left     = '0px';
        this.cover.style.top      = '0px';
        this.cover.style.width    = '100%';
        this.cover.style.height   = '100%';
        this.cover.style.margin   = '0px';
        this.cover.style.zOrder   = 500;
        //this.cover.style.backgroundColor='yellow';
        this.cover.disabled       = true;
        
        this.container.appendChild (this.cover);
    }
};

Cary.controls.GMPanel.prototype.addItem = function (itemText, divOptions, onClick, itemOptions)
{
    if (Cary.tools.isNothing (itemOptions))
        itemOptions = {};
    
    if (Cary.tools.isNothing (divOptions))
        divOptions = { left: 0, right: 0, width: '100%', height: 30, margin: 0, border: 'none', fontSize: 20, borderBottomStyle: 'solid', borderBottomColor: 'lightgray', borderBottomWidth: 1,
                       textAlign: 'center' };
    
    var checkMark = document.createElement ('div');
    var text      = document.createElement ('div');
    var item      = this.addSubPanel ({ display: 'block' });

    checkMark.style.width         = '20px';
    checkMark.style.height        = '100%';
    checkMark.style.textAlign     = 'left';
    checkMark.style.fontSize      = '18px';
    checkMark.style.lineHeight    = '5px';
    checkMark.style.display       = 'inline';
    checkMark.style.padding       = '8px';
    checkMark.style.margin        = '0px';
    checkMark.style.float         = 'left';
    checkMark.style.color         = ('checked' in itemOptions && itemOptions.checked) ? null : 'transparent';
    checkMark.style.cursor        = 'pointer';
    checkMark.style.userSelection = 'none';
    checkMark.innerText           = Cary.symbols.check;
    checkMark.item                = item;
    
    text.style.display         = 'inline';
    text.style.float           = 'left';
    text.style.marginRight     = '15px';
    text.style.cursor          = 'pointer';
    text.style.userSelection   = 'none';
    text.backgroundColor       = 'transparent';
    text.style.fontSize        = '15px';
    text.style.textAlign       = 'left';
    text.style.left            = '50px';
    text.style.width           = 'textWidth' in itemOptions ? Cary.tools.int2pix (itemOptions.textWidth) : '220px';
    text.style.padding         = '8px';
    text.style.paddingLeft     = '0px';
    text.innerText             = itemText;
    text.item                  = item;

    item.className = Cary.settings.activeItemClass;
    item.checkMark = checkMark;
    
    if ('data' in itemOptions)
        item.data = itemOptions.data;
    
    Cary.controls.setStyles (item, divOptions);
    
    if (!Cary.tools.isNothing (onClick))
    {
        text.onclick      = function () { onClick (this.item); };
        checkMark.onclick = text.onclick;
    }
    
    text.appendChild (checkMark);
    item.appendChild (text);
    
    return item;
};

Cary.controls.GMPanel.prototype.checkItem = function (item, check)
{
    item.checkMark.style.color = check ? null : 'transparent';
};

Cary.controls.GMPanel.prototype.isItemChecked = function (item)
{
    return item.checkMark.style.color !== 'transparent';
};

Cary.controls.MapMenu = function (map, position, items, options)
{
    var instance      = this;
    var hasCheckBoxes = false;
    var mapDiv        = map.getDiv ();
    
    Cary.controls.MapMenu.instances.push (this);
    
    if (Cary.tools.isNothing (items))
        items = {};
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    this.items     = items;
    this.options   = options;
    this.closeIcon = null;
    
    Cary.controls.GenericDomControl.apply (this, [map, position]);
    
    this.container.className = 'mapMenu';

    if ('title' in this.options)
    {
        var title = instance.addTitle (this.options.title);

        title.style.textAlign = 'left';
        
        this.closeIcon = document.createElement ('div');

        this.closeIcon.className = 'menuCloseIcon';
        this.closeIcon.innerText = Cary.symbols.cross;
        this.closeIcon.onclick   = function ()
                                   {
                                       if (instance.isLast ())
                                           instance.close ();
                                   };
    
        title.appendChild (this.closeIcon);
    }
    
    this.items.forEach (function (item)
                        {
                            hasCheckBoxes = hasCheckBoxes || ('checked' in item);
                        });
                        
    this.items.forEach (function (item)
                        {
                            if ('separator' in item && item.separator)
                                instance.addSeparator ();
                            else
                                instance.addItem (item);
                        });
                        
    // For top-level menus only:
    // Adjust position if needed (if it is out of the map div)
    if (Cary.controls.MapMenu.instances.length === 1)
    {
        if ((this.container.offsetLeft + this.container.offsetWidth) > mapDiv.offsetWidth)
            // Change tha anchor from right-handle to left-handle (from the position)
            this.container.style.left = Cary.tools.int2pix (this.container.offsetLeft - this.container.offsetWidth);

        if ((this.container.offsetTop + this.container.offsetHeight) > mapDiv.offsetHeight)
            // Change tha anchor from right-handle to left-handle (from the position)
            this.container.style.top = Cary.tools.int2pix (this.container.offsetTop - this.container.offsetHeight);
    }
};

Cary.controls.MapMenu.instances   = [];
Cary.controls.MapMenu.prototype   = Object.create (Cary.controls.GenericDomControl.prototype);
Cary.controls.MapMenu.getLastMenu = function () 
                                    {
                                        return Cary.controls.MapMenu.instances.length > 0 ? Cary.controls.MapMenu.instances [Cary.controls.MapMenu.instances.length-1] : null;
                                    };
Cary.controls.MapMenu.keyListener = document.addEventListener ('keydown',
                                                                function (event)
                                                                {
                                                                   if (event.keyCode === 27)
                                                                   {
                                                                       var lastMenu = Cary.controls.MapMenu.getLastMenu ();
                                                                       
                                                                       if (lastMenu !== null)
                                                                           lastMenu.close ();
                                                                   }
                                                                });

Cary.controls.MapMenu.prototype.isLast = function ()
{
    return Cary.controls.MapMenu.getLastMenu () === this;
};

Cary.controls.MapMenu.prototype.addTitle = function (titleText, titleOptions)
{
    if (Cary.tools.isNothing (titleOptions))
        titleOptions = {};
    
    var title = document.createElement ('div');

    title.innerText = titleText;
    title.className = 'mapMenuTitle';

    if ('data' in titleOptions)
        title.data = titleOptions.data;
    
    this.container.appendChild (title);
    
    return title;
};

Cary.controls.MapMenu.prototype.close = function ()
{
    Cary.controls.GenericDomControl.prototype.close.apply (this);
    
    Cary.controls.MapMenu.instances.splice (Cary.controls.MapMenu.instances.length - 1, 1);
};
 
Cary.controls.MapMenu.prototype.addSeparator = function ()
{
    var separator = document.createElement ('div');
    
    separator.className = 'mapMenuSeparator';
    
    this.container.appendChild (separator);
};

Cary.controls.MapMenu.prototype.addItem = function (itemData, itemOptions, hasCheckBoxes)
{
    var instance = this;
    
    if (Cary.tools.isNothing (hasCheckBoxes))
        hasCheckBoxes = false;
    
    if (Cary.tools.isNothing (itemOptions))
        itemOptions = {};
    
    var checkMark  = document.createElement ('div');
    var item       = document.createElement ('div');
    var openButton = 'subItems' in itemData ? document.createElement ('div') : null;
    var instance   = this;
    
    if (openButton !== null)
    {
        openButton.className = 'mapMenuOpenButton';
        openButton.innerText = Cary.symbols.toRight2;
        openButton.onclick   = openSubMenu;
        item.onclick         = openSubMenu;
        openButton.subItems  = itemData.subItems;
        openButton.itemDiv   = item;
    }
    
    if (hasCheckBoxes)
    {
        checkMark.innerText = Cary.symbols.check;
        checkMark.className = ('checked' in itemOptions && itemOptions.checked) ? 'checkMarkChecked' : 'checkMarkUnchecked';
        checkMark.item      = item;
    }
    
    item.className = 'mapMenuItem';
    item.checkMark = checkMark;
    item.innerText = itemData.text;
    item.menu      = this;

    if ('data' in itemOptions)
        item.data = itemOptions.data;
    
    if ('onClick' in itemData && openButton === null)
    {
        item.onclick = function ()
                       { 
                           if (instance.isLast ())
                               itemData.onClick (this);
                       };
        
        if (hasCheckBoxes)
            checkMark.onclick = item.onclick;
    }
    
    if (hasCheckBoxes)
        item.appendChild (checkMark);
    
    if (openButton !== null)
    {
        item.appendChild (openButton);
        
        item.subItems = itemData.subItems;
    }
    
    this.container.appendChild (item);
    
    return item;
    
    function openSubMenu ()
    {
        if (instance.isLast ())
        {
            var subItems = this.subItems;
            var itemDiv  = 'itemDiv' in this ? this.itemDiv : this;
            var mapDiv   = instance.map.getDiv ();
            var y        = itemDiv.offsetTop + instance.container.offsetTop;
            var x        = itemDiv.offsetLeft + instance.container.offsetLeft + itemDiv.offsetWidth + 20;
            var subMenu  = new Cary.controls.MapMenu (instance.map, { x: x, y: y }, subItems);

            if ((subMenu.container.offsetLeft + subMenu.container.offsetWidth) > mapDiv.offsetWidth)
                subMenu.container.style.left = Cary.tools.int2pix (instance.container.offsetLeft - subMenu.container.offsetWidth);

            if ((subMenu.container.offsetTop + subMenu.container.offsetHeight) > mapDiv.offsetHeight)
                subMenu.container.style.top = Cary.tools.int2pix (mapDiv.offsetHeight - subMenu.container.offsetHeight - 10);
        }
    }
};

Cary.drawers.GenericDrawer = function (userObject)
{
    this.object = userObject;
    
    this.object.drawObjects = [];
};

Cary.drawers.GenericDrawer.prototype.draw = function ()
{
    return null;
};

Cary.drawers.GenericDrawer.prototype.undraw = function ()
{
    if (this.object.drawObjects && this.object.drawObjects.length > 0)
    {
        var i;
        
        for (i = 0; i < this.object.drawObjects.length; ++ i)
            this.object.drawObjects [i].setMap (null);
        
        this.object.drawObjects = [];
    }
};

Cary.drawers.undrawLastDrawings = function (object)
{
    if (!Cary.tools.isNothing (object))
    {
        var i;
        
        for (i = 0; i < object.drawObjects.length; ++ i)
            object.drawObjects [i].setMap (null);
        
        object.drawObjects = [];
    }
};

Cary.drawers.PolylineDrawer = function (userObject)
{
    Cary.drawers.GenericDrawer.apply (this, arguments);
};

Cary.drawers.PolylineDrawer.prototype = Object.create (Cary.drawers.GenericDrawer.prototype);

Cary.drawers.PolylineDrawer.prototype.draw = function (map, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var instance   = this;
    var mapObject  = Cary.checkMap (map);
    var style      = this.object.properties ['lineStyle'];
    var editable   = 'editMode' in options && options.editMode;
    var clickable  = ('onClick' in options && options.onClick !== null) /*|| editable*/;
    var geodesic   = 'greatCircle' in options && options.greatCircle;
    var noBalloon  = 'noBalloon' in options && options.noBalloon;
    var dashed     = (style & Cary.userObjects.lineStyles.DASH) !== 0;
    var dotted     = (style & Cary.userObjects.lineStyles.DOT) !== 0;
    var arrowed    = (style & Cary.userObjects.lineStyles.ARROW) !== 0;
    var plOptions  = { clickable: clickable, draggable: false/*editable*/, editable: false/*editable*/, geodesic: geodesic, map: mapObject, strokeColor: this.object.properties ['color'],
                      strokeWeight: this.object.properties ['lineWidth'], visible: true, path: this.object.getGMPath () };
    var drawReally = !('createObject' in options) || options.createObject;
    var polyLine;
    
    if (dashed || dotted || arrowed)
    {
        var repeat;
        var lineSymbol;
        var iconOptions;

        if (arrowed)
        {
            lineSymbol = { path: 'M0 0 L 0 -10 L -2 -6 L 2 -6 L 0 -10', scale: 1, strokeOpacity: 1 };
            repeat     = '10px';
        }
        else if (dashed)
        {
            //lineSymbol  = { path: 'M 0,-2 0,0', strokeOpacity: 1, scale: 4 };
            lineSymbol  = { path: 'M 0,-1 0,0', strokeOpacity: 1, scale: 4 };
            repeat      = '10px';
        }
        else
        {
            lineSymbol  = { path: 'M 0,-1 0,0', strokeOpacity: 1, scale: 2 };
            repeat      = '10px';
        }

        iconOptions = { icon: lineSymbol, offset: '0', repeat: repeat };

        plOptions.icons = [iconOptions];

        if (dashed || dotted)
            plOptions.strokeWeight = 0;
    }

    if (drawReally)
    {
        polyLine = new google.maps.Polyline (plOptions);

        google.maps.event.addListener (polyLine, 'mouseover', onMouseOver);
        google.maps.event.addListener (polyLine, 'mouseout', onMouseOut);
    }
    else
    {
        polyLine = null;
    }
    
    this.object.drawObjects = polyLine === null ? [] : [polyLine];
    this.object.balloon     = null;
    this.plOptions          = plOptions;
    this.onMouseOver        = onMouseOver;
    this.onMouseOut         = onMouseOut;
    this.setUpVertex        = setUpVertex;
    this.editable           = editable;
    this.clickable          = clickable;
    
    if (drawReally && editable)
        instance.object.points.forEach (setUpVertex);
    
    return this.object.drawObjects;
    
    function setUpVertex (point)
    {
        var icon   = { path: google.maps.SymbolPath.CIRCLE, fillColor: 'yellow', strokeColor: plOptions.strokeColor, strokeWeight: 3, scale: 8 };
        var marker = new google.maps.Marker ({ draggable: true, icon: icon, map: map, position: { lat: point.lat, lng: point.lon } });

        marker.point = point;

        marker.addListener ('dragend', onDragEnd);
        marker.addListener ('drag', onDrag);

        instance.object.drawObjects.push (marker);

        function findPointIndexByMarker ()
        {
            var index;
            var i;

            for (i = 0, index = -1; i < instance.object.points.length; ++ i)
            {
                if (instance.object.points [i] === marker.point)
                {
                    index = i; break;
                }
            }

            return index;
        }

        function onDrag (event)
        {
            var index = findPointIndexByMarker ();

            if (index >= 0)
            {
                if ('onPointChanging' in options)
                    options.onPointChanging (index, { lat: event.latLng.lat (), lon: event.latLng.lng () });
            }
        }

        function onDragEnd (event)
        {
            var index = findPointIndexByMarker ();

            if (index >= 0)
            {
                var lat      = event.latLng.lat ();
                var lon      = event.latLng.lng ();
                var gmObject = instance.object.drawObjects [0];
                var path;
                
                switch (instance.object.type)
                {
                    case Cary.userObjects.objectTypes.POLYLINE:
                        path = gmObject.getPath (); break;
                        
                    case Cary.userObjects.objectTypes.POLYGON:
                        path = gmObject.getPaths ().getAt (0); break;

                    default:
                        return;
                }
                
                path.setAt (index, new google.maps.LatLng (lat, lon));

                switch (instance.object.type)
                {
                    case Cary.userObjects.objectTypes.POLYLINE:
                        gmObject.setPath (path); break;
                        
                    case Cary.userObjects.objectTypes.POLYGON:
                        gmObject.setPaths ([path]); break;
                }

                instance.object.points [index].lat = lat;
                instance.object.points [index].lon = lon;

                if ('onPointChanged' in options)
                    options.onPointChanged (index, instance.object.points [index]);
            }
        }
    }
    
    function onMouseOver (event)
    {
        if (!noBalloon && instance.object.balloon === null && !editable)
        {
            instance.object.balloon = new Cary.controls.MFBalloon (mapObject, event.latLng, { text: Cary.tools.unicode2char (instance.object.name) });
            
            instance.object.balloon.show ();
        }
    }
    
    function onMouseOut (event)
    {
        if (instance.object.balloon !== null)
        {
            instance.object.balloon.show (false);
            
            instance.object.balloon = null;
        }
    }
};

/*Cary.drawers.PolylineDrawer.prototype.undraw = function ()
{
    if (this.object.drawObjects.length > 0)
    {
        var i;
        
        for (i = 0; i < this.object.drawObjects.length; ++ i)
            this.object.drawObjects [i].setMap (null);
        
        this.object.drawObjects = [];
    }
};*/

Cary.drawers.PolylineDrawer.drawGeoPolyline = function (map, points, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var color     = 'color' in options ? options.color : Cary.userObjects.UserPolyline.DEFAULT_COLOR;
    var style     = 'style' in options ? options.style : Cary.userObjects.lineStyles.SOLID;
    var lineWidth = 'lineWidth' in options ? options.lineWidth : 2;
    var editable  = 'editMode' in options && options.editMode;
    var clickable = 'onClick' in options && options.onClick !== null;
    var geodesic  = 'greatCircle' in options && options.greatCircle;
    var dashed    = (style & Cary.userObjects.lineStyles.DASH) !== 0;
    var dotted    = (style & Cary.userObjects.lineStyles.DOT) !== 0;
    var arrowed   = (style & Cary.userObjects.lineStyles.ARROW) !== 0;
    var plOptions = { clickable: clickable, draggable: editable, editable: editable, geodesic: geodesic, map: map, strokeColor: color,
                      strokeWeight: lineWidth, visible: true, path: points };
                  
    if (dashed || dotted || arrowed)
    {
        var path;
        var repeat;
        var lineSymbol;
        var iconOptions;

        if (arrowed)
        {
            lineSymbol = { path: 'M0 0 L 0 -10 L -2 -6 L 2 -6 L 0 -10', scale: 1, strokeOpacity: 1 };
            repeat     = '10px';
        }
        else if (dashed)
        {
            lineSymbol  = { path: 'M 0,-2 0,0', strokeOpacity: 1, scale: 4 };
            repeat      = '20px';
        }
        else
        {
            lineSymbol  = { path: 'M 0,-2 0,0', strokeOpacity: 1, scale: 4 };
            repeat      = '50px';
        }

        iconOptions = { icon: lineSymbol, offset: '0', repeat: repeat };

        plOptions.icons = [iconOptions];

        if (dashed || dotted)
            plOptions.strokeWeight = 0;
    }

    return new google.maps.Polyline (plOptions);
    /*return new google.maps.Polyline ({ clickable: clickable, draggable: editable, editable: editable, geodesic: geodesic, map: map, strokeColor: color,
                                       strokeWeight: 0, visible: true, path: points,
                                       icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 4 }, offset: '0', repeat: '20px' }] });*/
};

Cary.drawers.PolygonDrawer = function (userObject)
{
    Cary.drawers.PolylineDrawer.apply (this, arguments);
    
    this.object.flashTimer = null;
};

Cary.drawers.PolygonDrawer.prototype = Object.create (Cary.drawers.PolylineDrawer.prototype);

Cary.drawers.PolygonDrawer.prototype.undraw = function ()
{
    if (this.object.flashTimer !== null)
        this.stopFlash ();
    
    Cary.drawers.PolylineDrawer.prototype.undraw.apply (this, arguments);
};

Cary.drawers.PolygonDrawer.prototype.draw = function (map, options)
{
    var polygon;
    var options;
    var drawMode;

    if (Cary.tools.isNothing (options))
        options = {};
    
    if ('drawMode' in options)
        drawMode = options.drawMode;
    else
        drawMode = null;
    
    // Prevent from drawing
    options.createObject = false;

    Cary.drawers.PolylineDrawer.prototype.draw.apply (this, [map, options]);
    
    this.plOptions.paths       = [this.plOptions.path];
    this.plOptions.fillColor   = this.object.getFillColor (drawMode);
    this.plOptions.strokeColor = this.object.getEdgeColor (drawMode);
    this.plOptions.fillOpacity = this.object.properties ['opacity'];
    
    polygon = new google.maps.Polygon (this.plOptions);
    
    google.maps.event.addListener (polygon, 'mouseover', this.onMouseOver);
    google.maps.event.addListener (polygon, 'mouseout', this.onMouseOut);
        
    this.object.drawObjects.push (polygon);
    
    if (this.editable)
        this.object.points.forEach (this.setUpVertex);
};

Cary.drawers.PolygonDrawer.prototype.startFlash = function (period)
{
    var instance = this;
    
    if (Cary.tools.isNothing (period))
        period = 1000;
    
    this.object.flashTimer = setInterval (switchFlashState, period);
    
    function switchFlashState ()
    {
        var polygon = instance.object.drawObjects [0];
        
        polygon.setVisible (!polygon.getVisible ());
    }
};

Cary.drawers.PolygonDrawer.prototype.stopFlash = function (period)
{
    if (this.object.flashTimer !== null)
    {
        clearInterval (this.object.flashTimer);
        
        this.object.flashTimer = null;
    }
};
    
/*
Cary.drawers.PolylineDrawer.drawGeoPolygon = function (map, points, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var color     = 'color' in options ? options.color : Cary.userObjects.UserPolyline.DEFAULT_COLOR;
    var fillColor = 'color' in options ? options.fillColor : Cary.userObjects.UserPolygon.DEFAULT_FILL_COLOR;
    var style     = 'style' in options ? options.style : Cary.userObjects.lineStyles.SOLID;
    var opacity   = 'opacity' in options ? options.opacity : Cary.userObjects.UserPolygon.DEFAULT_OPACITY;
    var lineWidth = 'lineWidth' in options ? options.lineWidth : 2;
    var editable  = 'editMode' in options && options.editMode;
    var clickable = 'onClick' in options && options.onClick !== null;
    var geodesic  = 'greatCircle' in options && options.greatCircle;
    var dashed    = (style & Cary.userObjects.lineStyles.DASH) !== 0;
    var dotted    = (style & Cary.userObjects.lineStyles.DOT) !== 0;
    var arrowed   = (style & Cary.userObjects.lineStyles.ARROW) !== 0;
    var plOptions = { clickable: clickable, draggable: editable, editable: editable, geodesic: geodesic, map: map, strokeColor: color,
                      strokeWeight: lineWidth, visible: true, path: points };
                  
    if (dashed || dotted || arrowed)
    {
        var path;
        var repeat;
        var lineSymbol;
        var iconOptions;

        if (arrowed)
        {
            lineSymbol = { path: 'M0 0 L 0 -10 L -2 -6 L 2 -6 L 0 -10', scale: 1, strokeOpacity: 1 };
            repeat     = '10px';
        }
        else if (dashed)
        {
            lineSymbol  = { path: 'M 0,-2 0,0', strokeOpacity: 1, scale: 4 };
            repeat      = '20px';
        }
        else
        {
            lineSymbol  = { path: 'M 0,-2 0,0', strokeOpacity: 1, scale: 4 };
            repeat      = '50px';
        }

        iconOptions = { icon: lineSymbol, offset: '0', repeat: repeat };

        plOptions.icons = [iconOptions];

        if (dashed || dotted)
            plOptions.strokeWeight = 0;
    }

    return new google.maps.Polyline (plOptions);
};
*/
Cary.drawers.IconDrawer = function (userObject)
{
    Cary.drawers.GenericDrawer.apply (this, arguments);
};

Cary.drawers.IconDrawer.prototype = Object.create (Cary.drawers.GenericDrawer.prototype);

Cary.drawers.IconDrawer.prototype.draw = function (map, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var mapObject = Cary.checkMap (map);
    var editable  = 'editMode' in options && options.editMode;
    //var clickable = 'onClick' in options && options.onClick !== null;
    var markerOpt = { clickable: true/*clickable*/, draggable: editable, map: mapObject, zIndex: 100, visible: true, title: this.object.name, 
                      position: { lat: this.object.position.lat, lng: this.object.position.lon }, icon: {} };
                  
    if ('path' in this.object.properties)
        markerOpt.icon.url = this.object.properties.path;

    this.object.drawObjects = [new google.maps.Marker (markerOpt)];
    
    return this.object.drawObjects;
};

Cary.drawers.IconGroupDrawer = function (userObject)
{
    Cary.drawers.GenericDrawer.apply (this, arguments);
};

Cary.drawers.IconGroupDrawer.prototype = Object.create (Cary.drawers.GenericDrawer.prototype);

Cary.drawers.IconGroupDrawer.prototype.draw = function (map, options)
{
    var instance = this;
    
    if (Cary.tools.isNothing (options))
        options = {};
    
    var mapObject = Cary.checkMap (map);
    var editable  = 'editMode' in options && options.editMode;
    var clickable = 'onClick' in options && options.onClick !== null;
    var markerOpt = { clickable: clickable, draggable: editable, map: mapObject, zIndex: 100, visible: true, title: this.object.name, position: {}, icon: {} };
                  
    if ('path' in this.object.properties)
        markerOpt.icon.url = this.object.properties.path;

    this.object.drawObjects = [];
    
    this.object.positions.forEach (function (position)
                                   {
                                       markerOpt.position.lat = position.lat;
                                       markerOpt.position.lng = position.lon;
                                       
                                       instance.object.drawObjects.push (new google.maps.Marker (markerOpt));
                                   });
    
    return this.object.drawObjects;
};

Cary.userObjects.objectTypes = {};
Cary.userObjects.lineStyles  = { SOLID: 1, DASH: 2, DOT: 4, ARROW: 8 };

Cary.userObjects.objectTypes.GENERIC_TYPE = 1;

Cary.userObjects.GenericUserObject = function (name)
{
    this.type        = Cary.userObjects.objectTypes.GENERIC_TYPE;
    this.userType    = null;
    this.name        = name;
    this.id          = 0;
    this.properties  = {};
    this.drawObjects = [];
    this.userProps   = {};
    this.attachments = [];
    this.userInfo    = null;    // Read-only
    this.userInfoID  = null;
};

Cary.userObjects.GenericUserObject.prototype.beforeShowHide = function (show) {};

Cary.userObjects.GenericUserObject.prototype.serialize = function ()
{
    return { type: this.type, id: this.id, name: this.name, properties: this.properties, userProps: this.userProps, userType: this.userType, userInfo: this.userInfo,
             userInfoID: this.userInfoID, attachments: this.attachments };
};

Cary.userObjects.GenericUserObject.prototype.getTypeName = function ()
{
    return (this.type === Cary.userObjects.objectTypes.GENERIC_TYPE) ? 'Generic' : '';
};

Cary.userObjects.GenericUserObject.prototype.getUserTypeName = function ()
{
    return null;
};

Cary.userObjects.GenericUserObject.prototype.getPropertyStringValue = function (propName, propValue)
{
    return propValue;
};

Cary.userObjects.GenericUserObject.prototype.getInfo = function ()
{
    var info = { type: this.getTypeName (), name: this.name, userProps: {} };
    
    for (var propName in this.properties)
        info [propName] = this.getPropertyStringValue (propName, this.properties [propName]);
    
    for (var key in this.userProps)
        info.userProps [key] = this.userProps [key];
    
    return info;
};

Cary.userObjects.GenericUserObject.prototype.deserialize = function (source)
{
    var instance = this;
    
    this.type        = source.type;
    this.name        = Cary.tools.unicode2char (source.name);
    this.id          = source.id;
    this.properties  = {};
    this.userProps   = {};
    this.attachments = [];
    
    Cary.tools.copyObjectProp (this, source, 'userInfo');
    Cary.tools.copyObjectProp (this, source, 'userInfoID');
    
    if ('userProps' in source)
    {
        for (var key in source.userProps)
            this.userProps [key] = Cary.tools.checkDecode (source.userProps [key]);
    }
    
    if ('properties' in source)
    {
        for (var key in source.properties)
            this.properties [key] = Cary.tools.checkDecode (source.properties [key]);
    }
    
    if ('attachments' in source)
    {
        source.attachments.forEach (function (attachment)
                                    {
                                        instance.attachments.push ({ name: attachment.name, data: attachment.data });
                                    });
    }
};

Cary.userObjects.GenericUserObject.prototype.toJSON = function ()
{
    return JSON.stringify (this.serialize ());
};

Cary.userObjects.GenericUserObject.prototype.fromJSON = function (source)
{
    this.deserialize (JSON.parse (source));
};

Cary.userObjects.GenericUserObject.prototype.save = function (fileName)
{
    if (Cary.tools.isNothing (fileName))
        fileName = this.name + '.uo';
    
    Cary.tools.saveFile (this.toJSON (), fileName);
};

Cary.userObjects.GenericUserObject.prototype.load = function (file)
{
    this.fromJSON (Cary.tools.loadFile (file));
};

Cary.userObjects.GenericUserObject.prototype.addProperty = function (name, value)
{
    this.properties [name] = value;
};

Cary.userObjects.GenericUserObject.prototype.createDrawer = function ()
{
    return new Cary.drawers.GenericDrawer (this);
};

Cary.userObjects.attachmentActions = { ADDED: 1, DELETED: 2, UPLOADED: 3 };

Cary.userObjects.GenericUserObject.prototype.buildAttachmentUpdateList = function (oldAttachmentList)
{
    var updates = [];
    var i;
    var j;
    var found;
    
    // First check for removed attachments
    for (i = 0; i < oldAttachmentList.length; ++ i)
    {
        for (j = 0, found = false; j < this.attachments.length; ++ j)
        {
            if (oldAttachmentList [i].name === this.attachments [j].name)
            {
                // We found the attachment with same name in new lisr; so it was not deleted
                found = true;
                
                // Make sure that attached data is the same, if not mark as uploaded
                if (oldAttachmentList [i].data !== this.attachments [j].data)
                    updates.push ({ name: oldAttachmentList [i].name, action: Cary.userObjects.attachmentActions.UPLOADED });
                
                break;
            }
        }
        
        if (!found)
            // It seems this attachment has been removed
            updates.push ({ name: oldAttachmentList [i].name, action: Cary.userObjects.attachmentActions.DELETED });
    }
    
    // Now check for newly added attachments (does not matter was something uploaded or not)
    for (i = 0; i < this.attachments.length; ++ i)
    {
        for (j = 0, found = false; j < oldAttachmentList.length; ++ j)
        {
            if (oldAttachmentList [j].name === this.attachments [i].name)
            {
                // We found the attachment with same name in both lists; so it was not added
                found = true; break;
            }
        }
        
        if (!found)
            // We found a new attachment (just added)
            updates.push ({ name: this.attachments [i].name, action: Cary.userObjects.attachmentActions.ADDED });
    }
    
    return updates;
};

Cary.userObjects.createFromArray = function (data, createUserObject)
{
    var object;
    
    if ('userType' in data && !Cary.tools.isNothing (createUserObject))
        object = createUserObject (data.userType);
    else
        object = null;
    
    if (object === null)
    {
        switch (data.type)
        {
            case Cary.userObjects.objectTypes.GENERIC_TYPE:
                object = new Cary.userObjects.GenericUserObject (); break;

            case Cary.userObjects.objectTypes.POLYLINE:
                object = new Cary.userObjects.UserPolyline (); break;

            case Cary.userObjects.objectTypes.POLYGON:
                object = new Cary.userObjects.UserPolygon (); break;

            case Cary.userObjects.objectTypes.ICON:
                object = new Cary.userObjects.UserIcon (); break;

            case Cary.userObjects.objectTypes.ICON_GROUP:
                object = new Cary.userObjects.UserIconGroup (); break;

            default:
                object = null;
        }
    }
    
    if (object !== null)
        object.deserialize (data);
    
    return object;
};

Cary.userObjects.createFromJSON = function (text, createUserObject)
{
    return Cary.userObjects.createFromArray (JSON.parse (text), createUserObject);
};

Cary.userObjects.ObjectCollection = function (name)
{
    this.objects    = [];
    this.name       = Cary.tools.isNothing (name) ? 'Objects' : name;
    this.drawn      = false;
    this.userInfo   = null; // Read-only
    this.userInfoID = null;
};

Cary.userObjects.ObjectCollection.prototype.serialize = function ()
{
    var result = { name: this.name, objects: [], userInfoID: this.userInfoID };
    
    if (!Cary.tools.isNothing (this.id))
        result.id = this.id;
    
    this.objects.forEach (function (object) { result.objects.push (object.serialize ()); });
    
    return result;
};

Cary.userObjects.ObjectCollection.prototype.deserialize = function (source, createUserObject)
{
    var instance = this;
    
    this.name    = source.name;
    this.id      = source.id;
    this.objects = [];
    
    Cary.tools.copyObjectProp (this, source, 'userInfo');
    Cary.tools.copyObjectProp (this, source, 'userInfoID');
    
    source.objects.forEach (function (objectDesc)
                            {
                                instance.objects.push (Cary.userObjects.createFromArray (objectDesc, createUserObject));
                            });
};

Cary.userObjects.ObjectCollection.prototype.findByProp = function (propName, propValue)
{
    var i;
    var result;
    
    for (i = 0, result = null; i < this.objects.length; ++ i)
    {
        if (this.objects [i].userProps [propName] === propValue)
        {
            result = this.objects [i]; break;
        }
    }
    
    return result;
};

Cary.userObjects.ObjectCollection.prototype.enumerate = function (callback)
{
    this.objects.forEach (callback);
};

Cary.userObjects.ObjectCollection.prototype.addFromJSON = function (text, createUserObject)
{
    var object = Cary.userObjects.createFromJSON (text, createUserObject);
    
    this.objects.push (object);
};

Cary.userObjects.ObjectCollection.prototype.findIndex = function (instance)
{
    var i;
    var result;
    
    for (i = 0, result = -1; i < this.objects.length; ++ i)
    {
        if (this.objects [i] === instance)
        {
            result = i; break;
        }
    }
    
    return result;
};

Cary.userObjects.MultiPointUserObject = function (name, points, properties)
{
    var instance = this;

    if (Cary.tools.isNothing (name))
        name = '';
    
    Cary.userObjects.GenericUserObject.apply (this, [name]);
    
    if (Cary.tools.isNothing (points))
        points = [];
    
    if (Cary.tools.isNothing (properties))
        properties = {};
    
    this.points     = [];
    this.properties = {};
    
    points.forEach (function (point) { instance.points.push (point); });
    
    for (var key in properties)
        this.properties [key] = properties [key];
};

Cary.userObjects.MultiPointUserObject.prototype = Object.create (Cary.userObjects.GenericUserObject.prototype);

Cary.userObjects.MultiPointUserObject.prototype.serialize = function ()
{
    var result = Cary.userObjects.GenericUserObject.prototype.serialize.apply (this, arguments);
    
    result.points     = this.points;
    result.properties = this.properties;
    
    return result;
};

Cary.userObjects.MultiPointUserObject.prototype.deserialize = function (source)
{
    var instance = this;
    
    Cary.userObjects.GenericUserObject.prototype.deserialize.apply (this, arguments);
    
    this.points     = [];
    this.properties = {};
    
    source.points.forEach (function (point) { instance.points.push (point); });
    
    for (var key in source.properties)
        this.properties [key] = source.properties [key];
};

Cary.userObjects.GenericUserObject.prototype.checkProperty = function (name, defValue)
{
    if (!(name in this.properties))
        this.properties [name] = defValue;
};

Cary.userObjects.GenericUserObject.prototype.getGMPath = function ()
{
    var result = [];
    
    this.points.forEach (function (point) { result.push ({ lat: point.lat, lng: point.lon }); });
    
    return result;
};

Cary.userObjects.GenericUserObject.prototype.setGMPath = function (path)
{
    var instance = this;
    
    this.points = [];
    
    path.forEach (function (vertex) { instance.points.push ({ lat: vertex.lat (), lon: vertex.lng () }); });
};

Cary.userObjects.UserPolyline = function (name, points, properties)
{
    Cary.userObjects.MultiPointUserObject.apply (this, arguments);

    this.type = Cary.userObjects.objectTypes.POLYLINE;
    
    Cary.userObjects.MultiPointUserObject.prototype.checkProperty.apply (this, ['color', Cary.userObjects.UserPolyline.DEFAULT_COLOR]);
    Cary.userObjects.MultiPointUserObject.prototype.checkProperty.apply (this, ['lineWidth', 3]);
    Cary.userObjects.MultiPointUserObject.prototype.checkProperty.apply (this, ['lineStyle', Cary.userObjects.lineStyles.SOLID]);
};

Cary.userObjects.UserPolyline.prototype = Object.create (Cary.userObjects.MultiPointUserObject.prototype);

Cary.userObjects.UserPolyline.DEFAULT_COLOR = 'blue';

Cary.userObjects.objectTypes.POLYLINE = 2;

Cary.userObjects.UserPolyline.prototype.createDrawer = function ()
{
    return new Cary.drawers.PolylineDrawer (this);
};

Cary.userObjects.UserPolyline.drawPolyline = function (map, points, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var color  = 'color' in options ? options.color : Cary.userObjects.UserPolyline.DEFAULT_COLOR;
    var style  = 'style' in options ? options.style : Cary.userObjects.lineStyles.SOLID;
    var object = new Cary.userObjects.UserPolyline ('temp', points, { color: color, style: style });
    var drawer = object.createDrawer ();
    
    return drawer.draw (map);
};

Cary.userObjects.UserPolyline.prototype.getLastPoint = function ()
{
    return this.points.length > 0 ? this.points [this.points.length-1] : null;
};

Cary.userObjects.UserPolyline.prototype.getTypeName = function ()
{
    var result;
    
    if (this.type === Cary.userObjects.objectTypes.POLYLINE)
        result = 'Polyline';
    else
        result = Cary.userObjects.GenericUserObject.prototype.getTypeName.apply (this);
    
    return result;
};

Cary.userObjects.UserPolyline.prototype.getInfo = function ()
{
    var info = Cary.userObjects.GenericUserObject.prototype.getInfo.apply (this);
    
    info ['Num of points'] = this.points.length.toString ();
    
    return info;
};

Cary.userObjects.UserPolyline.prototype.getPropertyStringValue = function (propName, propValue)
{
    var value;
    
    if (propName === 'lineStyle')
    {
        value = '';
        
        if (propValue & Cary.userObjects.lineStyles.ARROW)
            value += 'arrowed ';
        
        if (propValue & Cary.userObjects.lineStyles.DASH)
            value += 'dashed ';
        
        if (propValue & Cary.userObjects.lineStyles.DOT)
            value += 'dotted ';
        
        if (propValue & Cary.userObjects.lineStyles.SOLID)
            value += 'solid ';
        
        if (value === '')
            value = 'Not defined';
    }
    else
    {
        value = propValue;
    }
    
    return value;
};


Cary.userObjects.UserPolygon = function (name, points, properties)
{
    Cary.userObjects.UserPolyline.apply (this, arguments);

    this.type = Cary.userObjects.objectTypes.POLYGON;
    
    Cary.userObjects.MultiPointUserObject.prototype.checkProperty.apply (this, ['fillColor', Cary.userObjects.UserPolygon.DEFAULT_FILL_COLOR]);
    Cary.userObjects.MultiPointUserObject.prototype.checkProperty.apply (this, ['opacity', Cary.userObjects.UserPolygon.DEFAULT_OPACITY]);
};

Cary.userObjects.UserPolygon.prototype = Object.create (Cary.userObjects.UserPolyline.prototype);

Cary.userObjects.UserPolygon.DEFAULT_FILL_COLOR = 'yellow';
Cary.userObjects.UserPolygon.DEFAULT_OPACITY    = 0.5;

Cary.userObjects.objectTypes.POLYGON = 3;

Cary.userObjects.UserPolygon.prototype.createDrawer = function ()
{
    return new Cary.drawers.PolygonDrawer (this);
};

Cary.userObjects.UserPolygon.drawPolygon = function (map, points, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var color     = 'color' in options ? options.color : Cary.userObjects.UserPolyline.DEFAULT_COLOR;
    var fillColor = 'fillColor' in options ? options.fillColor : Cary.userObjects.UserPolygon.DEFAULT_FILL_COLOR;
    var style     = 'style' in options ? options.style : Cary.userObjects.lineStyles.SOLID;
    var opacity   = 'opacity' in options ? options.opacity : Cary.userObjects.UserPolygon.DEFAULT_OPACITY;
    var object    = new Cary.userObjects.UserPolygon ('temp', points, { color: color, style: style, fillColor: fillColor, opacity: opacity });
    var drawer    = object.createDrawer ();
    
    return drawer.draw (map);
};

Cary.userObjects.UserPolygon.prototype.getTypeName = function ()
{
    var result;
    
    if (this.type === Cary.userObjects.objectTypes.POLYGON)
        result = 'Polygon';
    else
        result = Cary.userObjects.GenericUserObject.prototype.getTypeName.apply (this);
    
    return result;
};

Cary.userObjects.UserPolygon.prototype.getInfo = function ()
{
    var info = Cary.userObjects.UserPolyline.prototype.getInfo.apply (this);
    
    info ['Fill color'] = this.properties ['fillColor'];
    info ['Opacity']    = this.properties ['opacity'].toFixed (1);
    
    return info;
};

Cary.userObjects.UserPolygon.prototype.getFillColor = function ()
{
    return this.properties ['fillColor'];
};

Cary.userObjects.UserPolygon.prototype.getEdgeColor = function ()
{
    return this.properties ['color'];
};
Cary.userObjects.UserIcon = function (name, position, properties)
{
    Cary.userObjects.GenericUserObject.apply (this, arguments);

    this.type       = Cary.userObjects.objectTypes.ICON;
    this.position   = position;
    this.properties = properties;
};

Cary.userObjects.UserIcon.prototype = Object.create (Cary.userObjects.GenericUserObject.prototype);

Cary.userObjects.objectTypes.ICON = 4;

Cary.userObjects.UserIcon.prototype.createDrawer = function ()
{
    return new Cary.drawers.IconDrawer (this);
};

Cary.userObjects.UserIcon.drawIcon = function (map, position, path, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var object = new Cary.userObjects.UserIcon ('temp', position, options);
    var drawer = object.createDrawer ();
    
    if (!Cary.tools.isNothing (path))
        object.properties ['path'] = path;
    
    return drawer.draw (map);
};

Cary.userObjects.UserIcon.prototype.getTypeName = function ()
{
    var result;
    
    if (this.type === Cary.userObjects.objectTypes.ICON)
        result = 'Icon';
    else
        result = Cary.userObjects.GenericUserObject.prototype.getTypeName.apply (this);
    
    return result;
};

Cary.userObjects.UserIcon.prototype.getInfo = function ()
{
    var info = Cary.userObjects.GenericUserObject.prototype.getInfo.apply (this);
    
    info ['Icon path'] = 'path' in this.properties ? this.properties ['path'] : 'Default';
    info ['Position']  = Cary.tools.formatLat (this.position.lat) + ' ' + Cary.tools.formatLon (this.position.lon);
    
    return info;
};

Cary.userObjects.UserIcon.prototype.serialize = function ()
{
    var result = Cary.userObjects.GenericUserObject.prototype.serialize.apply (this, arguments);
    
    result.properties.lat = this.position ? this.position.lat : null;
    result.properties.lon = this.position ? this.position.lon : null;
    
    return result;
};

Cary.userObjects.UserIcon.prototype.deserialize = function (source)
{
    Cary.userObjects.GenericUserObject.prototype.deserialize.apply (this, arguments);
    
    if ('lat' in source.properties && 'lon' in source.properties)
        this.position = { lat: parseFloat (source.properties.lat), lon: parseFloat (source.properties.lon) };
    else
        this.position = null;
};


Cary.userObjects.UserIconGroup = function (name, positions, properties)
{
    Cary.userObjects.GenericUserObject.apply (this, arguments);

    this.type      = Cary.userObjects.objectTypes.ICON_GROUP;
    this.positions = positions;
};

Cary.userObjects.UserIconGroup.prototype = Object.create (Cary.userObjects.GenericUserObject.prototype);

Cary.userObjects.objectTypes.ICON_GROUP = 4;

Cary.userObjects.UserIconGroup.prototype.createDrawer = function ()
{
    return new Cary.drawers.IconGroupDrawer (this);
};

Cary.userObjects.UserIconGroup.drawIcons = function (map, positions, path, options)
{
    if (Cary.tools.isNothing (options))
        options = {};
    
    var object = new Cary.userObjects.UserIconGroup ('temp', positions, options);
    var drawer = object.createDrawer ();
    
    if (!Cary.tools.isNothing (path))
        object.properties ['path'] = path;
    
    return drawer.draw (map);
};

Cary.userObjects.UserIconGroup.prototype.getTypeName = function ()
{
    var result;
    
    if (this.type === Cary.userObjects.objectTypes.ICON_GROUP)
        result = 'Icon group';
    else
        result = Cary.userObjects.GenericUserObject.prototype.getTypeName.apply (this);
    
    return result;
};

Cary.userObjects.UserIconGroup.prototype.getInfo = function ()
{
    var info = Cary.userObjects.GenericUserObject.prototype.getInfo.apply (this);
    
    info ['Icon path']    = 'path' in this.properties ? this.properties ['path'] : 'Default';
    info ['Num of icons'] = this.positions.length;
    
    return info;
};

Cary.userObjects.UserIconGroup.prototype.serialize = function ()
{
    var result = Cary.userObjects.GenericUserObject.prototype.serialize.apply (this, arguments);
    
    result.positions = this.positions;
    
    return result;
};

Cary.userObjects.UserIconGroup.prototype.deserialize = function (source)
{
    Cary.userObjects.GenericUserObject.prototype.deserialize.apply (this, arguments);
    
    this.positions = source.positions;
};


Cary.ui.Window = function (desc)
{
    var instance = this;
    var paneMode;
    var attach;
    
    if (Cary.tools.isNothing (desc))
        desc = {};
    
    attach   = 'attach' in desc ? desc.attach : null;
    paneMode = 'paneMode' in desc && desc.paneMode;
    
    if (paneMode)
        desc.noCloseIcon = true;
    
    this.wnd       = attach === null ? document.createElement ('div') : attach;
    this.closeIcon = paneMode ? null : document.createElement ('div');
    this.client    = paneMode ? null : document.createElement ('div');
    this.parent    = Cary.tools.isNothing (desc.parent) ? document.getElementsByTagName ('body') [0] : desc.parent;
    this.desc      = desc;
    this.adjustPos = function () { adjustPosition (this); };
    
    if (this.closeIcon !== null)
    {
        this.closeIcon.className = 'windowCloseIcon';
        this.closeIcon.onclick   = function () { instance.close () };
        this.closeIcon.innerText = Cary.symbols.cross;
    }

    if (paneMode)
        this.wnd.className = 'pane';
    else if (attach === null)
        this.wnd.className = 'window';
    else
        this.wnd.className = 'attachedWindow';
        
    this.wnd.id        = 'id' in desc ? desc.id : null;
    this.wnd.innerText = 'title' in desc ? desc.title : '';

    adjustPosition (this);
    
    if (this.client !== null)
    {
        this.client.className = 'windowClient';
        this.client.id        = this.wnd.id === null ? null : this.wnd.id + '_client';
    
        if ('padding' in desc)
        {
            if (typeof (desc.padding) === 'number')
                this.client.style.padding = int2pix (desc.padding);
            else
                this.client.style.padding = desc.padding;
        }

        this.wnd.appendChild (this.client);
    }
    
    if (!('noCloseIcon' in desc) || !desc.noCloseIcon)
        this.wnd.appendChild (this.closeIcon);

    this.onInitialize ();
    
    if ('visible' in desc && desc.visible)
        this.show ();

    function adjustPosition (instance)
    {
        function getWidth ()
        {
            var result;
            
            if (desc.position.width === null)
                result = 'fit-content';
            else if (typeof (desc.position.width) === 'number')
                result = Cary.tools.int2pix (desc.position.width);
            else
                result = desc.position.width;
            
            return result; //desc.position.width === null ? 'fit-content' : Cary.tools.int2pix (desc.position.width);
        }
        
        function getHeight ()
        {
            var result;
            
            if (desc.position.height === null)
                result = 'fit-content';
            else if (typeof (desc.position.height) === 'number')
                result = Cary.tools.int2pix (desc.position.height);
            else
                result = desc.position.height;
            
            return result; //desc.position.width === null ? 'fit-content' : Cary.tools.int2pix (desc.position.width);
        }
        
        if ('position' in desc)
        {
            if ('hcenter' in desc.position && desc.position.hcenter)
            {
                instance.wnd.style.left  = Cary.tools.int2pix ((window.innerWidth - desc.position.width) >> 1);
                instance.wnd.style.width = getWidth ();
            }
            else
            {
                if ('left' in desc.position)
                    instance.wnd.style.left = Cary.tools.int2pix (desc.position.left);

                if ('width' in desc.position)
                    instance.wnd.style.width = getWidth ();

                if ('right' in desc.position)
                    instance.wnd.style.right = Cary.tools.int2pix (desc.position.right);
            }

            if ('vcenter' in desc.position && desc.position.vcenter)
            {
                instance.wnd.style.top    = Cary.tools.int2pix ((window.innerHeight - desc.position.height) >> 1);
                instance.wnd.style.height = getHeight ();
            }
            else
            {
                if ('top' in desc.position)
                    instance.wnd.style.top = Cary.tools.int2pix (desc.position.top);

                if ('height' in desc.position)
                    instance.wnd.style.height = getHeight ();

                if ('bottom' in desc.position)
                    instance.wnd.style.bottom = Cary.tools.int2pix (desc.position.bottom);
            }
            
            if ('absolute' in desc.position && desc.position.absolute)
                instance.wnd.style.position = 'absolute';
        }
    }
};

Cary.ui.Window.prototype.onInitialize = function ()
{
};

Cary.ui.Window.prototype.close = function (quiet)
{
    if (Cary.tools.isNothing (quiet))
        quiet = false;
    
    if (quiet || this.queryClose ())
    {
        if ('onClose' in this.desc)
            this.desc.onClose ();

        this.hide ();

        this.wnd.removeChild (this.client);
        this.wnd.removeChild (this.closeIcon);
    }
};

Cary.ui.Window.prototype.open = function ()
{
    this.onInitialize ();
    this.show ();
};

Cary.ui.Window.prototype.show = function ()
{
    this.parent.appendChild (this.wnd);
};

Cary.ui.Window.prototype.hide = function ()
{
    if (this.parent.contains (this.wnd))
        this.parent.removeChild (this.wnd);
};

Cary.ui.Window.prototype.queryClose = function ()
{
    return true;
};

Cary.ui.Window.prototype.setTitle = function (title)
{
    this.wnd.firstChild.data = title;
};

Cary.ui.Window.prototype.setWidth = function (width)
{
    if (typeof (width) === 'number')
        this.wnd.style.width = Cary.tools.int2pix (width);
    else
        this.wnd.style.width = width;
};

Cary.ui.Window.prototype.setHeight = function (height)
{
    var top;
    var oldHeight = parseInt (this.wnd.style.height);
    
    if (typeof (height) === 'number')
    {
        this.wnd.style.height = Cary.tools.int2pix (height);
    }
    else
    {
        this.wnd.style.height = height;
        
        height = parseInt (height);
    }
    
    top = parseInt (this.wnd.style.top);
    
    if (top > 0)
    {
        top -= (height - oldHeight) / 2;
    
        this.wnd.style.top = Cary.tools.int2pix (top)
    }
};

Cary.ui.anchor = { NONE: 0, TOP: 1, BOTTOM: 2, LEFT: 4, RIGHT: 8 };

Cary.ui.Control = function (desc, styles)
{
    this.styles     = Cary.tools.isNothing (styles) ? {} : styles;
    this.htmlObject = null;
    this.desc       = desc;
    this.parent     = 'parent' in desc ? desc.parent : document.getElementsByTagName ('body') [0];
    
    this.initialize ();
};

Cary.ui.Control.prototype.getParam = function (name, defValue)
{
    if (Cary.tools.isNothing (defValue))
        defValue = null;
    
    return name in this.desc ? this.desc [name] : defValue;
};

Cary.ui.Control.prototype.show = function (visible)
{
    if (Cary.tools.isNothing (visible))
        visible = true;
    
    if (this.htmlObject !== null)
    {
        if (visible && this.parent && !this.parent.contains (this.htmlObject))
            this.parent.appendChild (this.htmlObject);
        
        this.htmlObject.style.display = visible ? null : 'none';
    }
};

Cary.ui.Control.prototype.enable = function (enabled)
{
    if (Cary.tools.isNothing (enabled))
        enabled = true;
    
    if (this.htmlObject !== null)
        this.htmlObject.disabled = enabled ? null : true;
};

Cary.ui.Control.prototype.setValue = function (value)
{
    if (Cary.tools.isNothing (value))
        value = null;
    
    if (this.htmlObject !== null)
        this.htmlObject.value = value;
};

Cary.ui.Control.prototype.getValue = function ()
{
    return (this.htmlObject !== null) ? this.htmlObject.value : null;
};

Cary.ui.Control.prototype.setText = function (text)
{
    if (Cary.tools.isNothing (text))
        text = null;
    
    if (this.htmlObject !== null)
        this.htmlObject.innerText = text;
};

Cary.ui.Control.prototype.initialize = function ()
{
    if (this.htmlObject !== null)
    {
        var styleValue;
        var anchor = this.getParam ('anchor', Cary.ui.anchor.NONE);

        if ('id' in this.desc)
            this.htmlObject.id = this.desc.id;
        
        if ('className' in this.desc)
            this.htmlObject.className = this.desc.className;
        
        for (var styleName in this.styles)
            this.setStyle (styleName, this.styles [styleName]);

        if (anchor !== Cary.ui.anchor.NONE)
        {
            this.setStyle ('position', 'absolute');
            
            if (anchor & Cary.ui.anchor.TOP)
                this.setStyle ('top', 0);
                
            if (anchor & Cary.ui.anchor.BOTTOM)
                this.setStyle ('bottom', 0);
                
            if (anchor & Cary.ui.anchor.LEFT)
                this.setStyle ('left', 0);
                
            if (anchor & Cary.ui.anchor.RIGHT)
                this.setStyle ('right', 0);                
        }
        
        if ('visible' in this.desc && this.desc.visible)
            this.show ();
        
        if ('onClick' in this.desc)
            this.htmlObject.onclick = this.desc.onClick;
    }
};

Cary.ui.Control.prototype.setStyle = function (styleName, styleValue)
{
    if (typeof (styleValue) === 'number')
        this.htmlObject.style [styleName] = Cary.tools.int2pix (styleValue);
    else
        this.htmlObject.style [styleName] = styleValue;
};

// Control block implementation
Cary.ui.ControlBlock = function (desc, styles)
{
    if (!('className' in desc))
        desc.className = 'ctlBlock';
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.ControlBlock.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.ControlBlock.prototype.initialize = function ()
{
    this.htmlObject           = document.createElement ('div');
    this.htmlObject.innerText = this.getParam ('text');
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};
    
Cary.ui.Button = function (desc, styles)
{
    if (!('className' in desc))
        desc.className = 'button';
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.Button.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.Button.prototype.initialize = function ()
{
    this.htmlObject       = document.createElement ('input');
    this.htmlObject.value = this.getParam ('text');
    this.htmlObject.type  = 'button';    

    if ('onClick' in this.desc)
        this.htmlObject.onclick = this.desc.onClick;
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};

Cary.ui.Button.prototype.setClickHandler = function (handler)
{
    this.htmlObject.onclick = handler;
};

Cary.ui.PopUpMenu = function (desc, styles)
{
    this.popupItems = [];
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.PopUpMenu.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.PopUpMenu.prototype.initialize = function ()
{
    var instance = this;
    
    this.anchorElement = 'anchorElement' in this.desc ? this.desc.anchorElement : null;
    this.htmlObject    = document.createElement ('div');
    
    this.htmlObject.className = 'popUpMenu';
    
    if ('menuWidth' in this.desc && this.desc.menuWidth !== null)
        this.htmlObject.style.width = Cary.tools.int2pix (this.desc.menuWidth);
    
    this.desc.items.forEach (function (item) { instance.addMenuItem (item); });

    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};

Cary.ui.PopUpMenu.prototype.addMenuItem = function (item)
{
    var itemDiv  = document.createElement ('div');
    var instance = this;

    itemDiv.innerText  = item.text;
    itemDiv.onclick    = function ()
                         {
                             instance.show (false);

                             if ('param' in item)
                                item.action (item.param);
                            else
                                item.action ();
                         };
    itemDiv.className  = 'popUpMenuItem';
    itemDiv.onmouseout = onMouseOut;

    this.htmlObject.appendChild (itemDiv);

    this.popupItems.push (itemDiv);

    function onMouseOut (event)
    {
        this.mouseIn = false;

        if (event.relatedTarget.className !== 'popUpMenuItem')
            instance.show (false);
    }
};

Cary.ui.PopUpMenu.prototype.show = function (visible)
{
    if (this.anchorElement !== null)
    {
        if (visible)
        {
            if (this.htmlObject.style.width === null || this.htmlObject.style.width === '')
                this.htmlObject.style.width  = Cary.tools.int2pix (this.anchorElement.offsetWidth);
            
            this.htmlObject.style.height = 'fit-content';
            
            if (this.desc.anchorType & Cary.ui.anchor.BOTTOM)
            {
                this.htmlObject.style.bottom  = Cary.tools.int2pix (this.anchorElement.offsetHeight + 10);
                
                if (this.desc.anchorType & Cary.ui.anchor.LEFT)
                    this.htmlObject.style.left = Cary.tools.int2pix (this.anchorElement.offsetLeft);
                else
                    this.htmlObject.style.right = Cary.tools.int2pix (this.anchorElement.offsetLeft + this.anchorElement.offsetWidth);
            }
            else if (this.desc.anchorType & Cary.ui.anchor.TOP)
            {
                this.htmlObject.style.top  = Cary.tools.int2pix (this.anchorElement.offsetTop + this.anchorElement.offsetHeight);
                
                if (this.desc.anchorType & Cary.ui.anchor.LEFT)
                    this.htmlObject.style.left = Cary.tools.int2pix (this.anchorElement.offsetLeft);
                else
                    this.htmlObject.style.right = Cary.tools.int2pix (this.anchorElement.offsetLeft + this.anchorElement.offsetWidth);
            }
            else if (this.desc.anchorType & Cary.ui.anchor.LEFT)
            {
                this.htmlObject.style.left = Cary.tools.int2pix (this.anchorElement.offsetLeft + this.anchorElement.offsetWidth);
            }
            else if (this.desc.anchorType & Cary.ui.anchor.RIGHT)
            {
                this.htmlObject.style.right = Cary.tools.int2pix (this.anchorElement.offsetLeft);
            }
                
            this.anchorElement.parentElement.appendChild (this.htmlObject);
        }
        else
        {
            this.anchorElement.parentElement.removeChild (this.htmlObject);
        }
    }
};

Cary.ui.PopUpButton = function (desc, styles)
{
    Cary.ui.Control.apply (this, arguments);
};
    
Cary.ui.PopUpButton.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.PopUpButton.prototype.initialize = function ()
{
    var instance = this;
    
    this.htmlObject  = document.createElement ('div');
    this.label       = document.createElement ('div');
    this.popupOpener = document.createElement ('div');

    this.popupOpener.className = 'popUpOpener';
    this.popupOpener.innerText = Cary.symbols.downArrow;
    this.popupOpener.onclick   = function () { instance.showPopUp (true); };

    this.htmlObject.appendChild (this.popupOpener);
    this.htmlObject.appendChild (this.label);
    
    this.htmlObject.className = 'popUpButton';
    this.htmlObject.onclick   = this.popupOpener.onclick;
    
    this.label.innerText = this.desc.text;
    this.label.className = 'popUpLabel';
    this.label.onclick   = this.popupOpener.onclick;
    
    if ('fontSize' in this.desc)
        this.label.style.fontSize = Cary.tools.int2pix (this.desc.fontSize);
    
    if ('lineHeight' in this.desc)
        this.label.style.lineHeight = Cary.tools.int2pix (this.desc.lineHeight);
    
    if ('textTop' in this.desc)
        this.label.style.marginTop = Cary.tools.int2pix (this.desc.textTop);

    Cary.ui.Control.prototype.initialize.apply (this, arguments);
    
    this.menu = new Cary.ui.PopUpMenu ({ anchorElement: this.htmlObject, anchorType: this.desc.anchorType, items: this.desc.popupMenu  }, { width: this.desc.menuWidth });
};

Cary.ui.PopUpButton.prototype.enable = function (enable)
{
    var color = enable ? null : 'gray';

    this.htmlObject.disabled     = enable ? null : 'disabled';
    this.label.style.color       = color;
    this.popupOpener.style.color = color;
};

Cary.ui.PopUpButton.prototype.center = function ()
{
    this.htmlObject.style.margin = 'auto';
};    

Cary.ui.PopUpButton.prototype.showPopUp = function (show)
{
    if (!this.htmlObject.disabled)
        this.menu.show (show);
};

Cary.ui.EditBox = function (desc, styles)
{
    if (!('className' in desc))
        desc.className = 'editBox';
    
    Cary.ui.Control.apply (this, arguments);    
};

Cary.ui.EditBox.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.EditBox.prototype.initialize = function ()
{
    this.htmlObject = document.createElement ('input');
    this.numeric    = 'numeric' in this.desc && this.desc.numeric;
    this.float      = 'float' in this.desc && this.desc.float;

    this.htmlObject.type      = this.numeric ? 'number' : 'text';
    this.htmlObject.id        = 'id' in this.desc ? this.desc.id : null;
    this.htmlObject.className = 'editBox';
  
    if ('onChange' in this.desc)
    {
        this.htmlObject.onchange = this.desc.onChange;
        this.htmlObject.oninput  = this.desc.onChange;
    }
    
    if (this.float)
        this.htmlObject.value = 'value' in this.desc ? this.desc.value : 0.0;
    else if (this.numeric)
        this.htmlObject.value = 'value' in this.desc ? this.desc.value : 0;
    else
        this.htmlObject.value = 'text' in this.desc ? this.desc.text : '';

    if (this.numeric)
    {
        if ('max' in this.desc)
            this.htmlObject.max = this.desc.max;
        
        if ('min' in this.desc)
            this.htmlObject.min = this.desc.min;
        
        if ('step' in this.desc)
            this.htmlObject.step = this.desc.step;
        
        if ('maxLength' in this.desc)
            this.htmlObject.maxlength = this.desc.maxLength;
    }
    else
    {
        if ('upperCase' in this.desc && this.desc.upperCase)
            this.htmlObject.style.textTransform = 'uppercase';
    }
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};

Cary.ui.EditBox.prototype.getValue = function ()
{
    var value;
    
    if (this.htmlObject !== null)
    {
        value = this.htmlObject.value;

        if (this.float)
            value = value === '' ? 0.0 : parseFloat (value);
        else if (this.numeric)
            value = value === '' ? 0 : parseInt (value);
    }
    else
    {
        value = null;
    }
    
    return value;
};

function SpinableEditBox (desc)
{
    var container   = document.createElement ('div');
    var incButton   = document.createElement ('button');
    var decButton   = document.createElement ('button');
    var value       = 'value' in desc ? desc.value : 0;
    var isFloat     = 'float' in desc ? desc.float : false;
    var parent      = 'parent' in desc ? desc.parent : document.getElementsByTagName ('body') [0];
    var onChange    = 'onChange' in desc ? desc.onChange : null;
    var contClass   = 'containerClass' in desc ? desc.containerClass : null;
    var control;
    var controlDesc = { parent: container, text: value.toString (), left: 0, /*right: 35, position: 'absolute'*/ };
    var fields      = ['max', 'min', 'step', 'maxLength', 'rightMargin', 'lineHeight', 'fontSize', 'hidden', 'toRight',
                       'top', 'left', 'height', 'width', 'right', 'bottom', 'position', 'backgroundColor', 'color', 'textAlign',
                       'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'className'];

    fields.forEach (function (field)
                    {
                        if (field in desc)
                            controlDesc [field] = desc [field];
                    });

    if ('onLostFocus' in desc)
        controlDesc.onLostFocus = desc.onLostFocus;
    
    if ('width' in desc)
        controlDesc.width = desc.width - 38;
    
    if (onChange)
        controlDesc.onChange = onChange;
    
    controlDesc.toRight     = false;
    controlDesc.rightMargin = 0;
    controlDesc.numeric     = false;
    
    container.className = 'spinableBox';
    
    if (contClass !== null)
        container.className += ' ' + contClass;
    
    initAttachControl (this, container, desc);

    container.style.backgroundColor = 'transparent';

    this.getValue = getValue;
    this.setValue = setValue;
    this.enable   = enable;
    
    incButton.className = 'spinUpButton';
    incButton.innerText = '▲';
    incButton.onclick   = increase;
    
    decButton.className = 'spinDnButton';
    decButton.innerText = '▼';
    decButton.onclick   = decrease;
    
    container.appendChild (decButton);
    
    control = new EditBox (controlDesc);

    enable (!(('disabled' in desc) && desc.disabled));
    
    container.appendChild (incButton);
    
    control.htmlObject.style.borderStyle     = 'none';
    control.htmlObject.style.borderWidth     = '0px';
    control.htmlObject.style.marginLeft      = '0px';
    control.htmlObject.style.marginRight     = '0px';
    control.htmlObject.style.width           = int2pix (container.clientWidth - incButton.clientWidth - decButton.clientWidth - 10);
    
    function getValue ()
    {
        return control.getValue ();
    }
    
    function setValue (value)
    {
        setControlValue (value);
    }
    
    function enable (enabled)
    {
        control.enable (enabled);
        
        incButton.disabled = control.htmlObject.disabled;
        decButton.disabled = control.htmlObject.disabled;
    }
    
    function setControlValue (value)
    {
        if ('digitsAfterComma' in desc)
            control.setValue (value.toFixed (desc.digitsAfterComma));
        else
            control.setValue (value);
    }
    
    function increase ()
    {
        var text  = control.getValue ();
        var value = isFloat ? parseFloat (text) : parseInt (text);
        var max   = 'max' in desc ? desc.max : 1E10;
        var step  = 'step' in desc ? desc.step : 1;
        
        if (value + step <= max)
            setControlValue (value + step);
        
        if (onChange)
            onChange ();
    }
    
    function decrease ()
    {
        var text  = control.getValue ();
        var value = isFloat ? parseFloat (text) : parseInt (text);
        var min   = 'min' in desc ? desc.min : -1E10;
        var step  = 'step' in desc ? desc.step : 1;
        
        if (value - step >= min)
            setControlValue (value - step);
        
        if (onChange)
            onChange ();
    }
}

Cary.ui.TreeView = function (desc, styles)
{
    this.rootItem     = { tree: this, text: null, data: null, parent: null, subItems: [], expanded: false, itemObject: null, subItemListObject: null, level: 0 };
    this.selectedItem = null;
    this.indent       = 'indent' in desc ? desc.indent : 15;
    this.autoSelect   = 'autoSelect' in desc ? desc.autoSelect : false;
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.TreeView.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.TreeView.prototype.initialize = function ()
{
    this.htmlObject   = document.createElement ('div');
    this.rootItemList = document.createElement ('ul');

    this.htmlObject.className  = 'treeView';

    this.rootItem.subItemListObject = this.rootItemList;

    this.htmlObject.appendChild (this.rootItemList);

    Cary.ui.Control.prototype.initialize.apply (this);
    
    this.drawChildren (this.rootItem);
};
    
Cary.ui.TreeView.prototype.getRootItem = function ()
{
    return rootItem;
};
    
Cary.ui.TreeView.prototype.enumChildItems = function (item, callback)
{
    if ('subItems' in item && item.subItems !== null)
        item.subItems.forEach (callback);
};
    
Cary.ui.TreeView.prototype.collapseAllItems = function (item)
{
    var instance = this;
    
    if (Cary.tools.isNothing (item))
        item = this.rootItem;

    item.subItems.forEach (function (subItem)
                           {
                               instance.collapseItem (subItem);
                               instance.collapseAllItems (subItem);
                           });
};
    
Cary.ui.TreeView.prototype.setItemText = function (item, text)
{
    item.text                 = text;
    item.itemObject.innerHTML = text;
};
    
Cary.ui.TreeView.prototype.setItemData = function (item, data)
{
    item.data = data;
};
    
Cary.ui.TreeView.prototype.addItem = function (parentItem, text, data)
{
    var instance = this;
        
    if (parentItem === null)
        parentItem = this.rootItem;

    var subItemListObject = document.createElement ('ul');
    var itemObject        = document.createElement ('li');
    var item              = { tree: this.rootItem.tree, text: text, data: data, parent: parentItem, subItems: [], expanded: false, itemObject: itemObject, 
                              subItemListObject: subItemListObject, level: parentItem.level + 1 };

    itemObject.className  = 'tvItem';
    itemObject.innerHTML  = text;
    itemObject.onclick    = function (event) { Cary.ui.TreeView.prototype.onItemClick.apply (instance, [event]) };
    itemObject.ondblclick = function (event) { Cary.ui.TreeView.prototype.onItemDblClick.apply (instance, [event]); };

    if (this.autoSelect)
        itemObject.onmousemove = function (event) { Cary.ui.TreeView.prototype.onItemMouseMove.apply (instance, [event]); };
    
    subItemListObject.className        = 'tvSubItem';
    subItemListObject.style.marginLeft = Cary.tools.int2pix (this.indent);

    if (!Array.isArray (parentItem.subItems))
        parentItem.subItems = [];

    parentItem.subItems [parentItem.subItems.length] = item;

    this.collapseItem (parentItem);
    this.expandItem (parentItem);

    return item;
};
    
Cary.ui.TreeView.prototype.collapseItem = function (item)
{
    if (item.expanded)
    {
        if (item.parent !== null && item.parent.subItemListObject !== null)
            item.parent.subItemListObject.removeChild (item.subItemListObject);

        while (item.subItemListObject.children.length > 0)
            item.subItemListObject.removeChild (item.subItemListObject.children [0]);

        if (item.itemObject !== null)
            item.itemObject.style.listStyleImage = 'url(res/rgt_arr.png)';

        item.expanded = false;
    }
};
    
Cary.ui.TreeView.prototype.expandItem = function (item)
{
    if (!item.expanded && Array.isArray (item.subItems))
    {
        var subItem;
        var subItemObject;
        var subItemSubItemList;
        var i;

        if (item.parent !== null && item.parent.subItemListObject !== null)
            Cary.tools.insertChildAfter (item.parent.subItemListObject, item.subItemListObject, item.itemObject);

        for (i = 0; i < item.subItems.length; ++ i)
        {
            subItem            = item.subItems [i];
            subItemObject      = subItem.itemObject;
            subItemSubItemList = subItem.subItemListObject;

            item.subItemListObject.appendChild (subItemObject);

            if (subItem.subItems.length > 0)
            {
                subItem.expanded = subItemSubItemList.children.length > 0;

                subItemObject.style.listStyleImage = subItem.expanded ? 'url(res/dn_arr.png)' : 'url(res/rgt_arr.png)';
                subItemObject.style.listStyleType  = 'none';
            }
            else
            {
                subItemObject.style.listStyleImage = 'none';
                subItemObject.style.listStyleType  = 'none';
            }

            item.subItemListObject.appendChild (subItemSubItemList);
        }

        item.expanded = true;

        if (item.itemObject !== null)
            item.itemObject.style.listStyleImage = 'url(res/dn_arr.png)';
    }
};
    
Cary.ui.TreeView.prototype.deleteItem = function (item)
{
    var i;

    // Remove html elements
    if (item.itemObject !== null)
        item.parent.subItemListObject.removeChild (item.itemObject);

    if (item.subItemListObject !== null)
        item.parent.subItemListObject.removeChild (item.subItemListObject);

    for (i = 0; i < item.parent.subItems.length; ++ i)
    {
       if (item.parent.subItems [i] === item)
       {
           item.parent.subItems.splice (i, 1); break;
       }
    }
};

Cary.ui.TreeView.prototype.deleteAllItems = function ()
{
    while (this.rootItem.subItems.length > 0)
        this.deleteItem (this.rootItem.subItems [0]);
};
    
Cary.ui.TreeView.prototype.drawChildren = function (item)
{
    var list;

    if (item.subItemListObject === null)
    {
        list = document.createElement ('ul');

        item.parent.subItemListObject.appendChild (list);
    }
    else
    {
        list = item.subItemListObject;
    }

    list.className        = 'tvItem';
    list.style.marginLeft = Cary.tools.int2pix (this.indent);

    if (Array.isArray (item.subItems))
    {
        var subItem;
        var itemObject;
        var i;

        for (i = 0; i < item.subItems.length; ++ i)
        {
            subItem    = item.subItems [i];
            itemObject = document.createElement ('li');

            if (!isArray (subItem.subItems))
            {
                itemObject.style.listStyleImage = 'none';
            }
            else if (subItem.expanded)
            {
                itemObject.style.listStyleImage = 'url(res/dn_arr.png)';

                this.drawChildren (subItem, list);
            }
            else
            {
                itemObject.style.listStyleImage = 'url(res/rgt_arr.png)';
            }

            itemObject.style.textAlign = 'left';
            itemObject.innerHTML       = subItem.text;

            subItem.itemObject = itemObject;

            list.appendChild (itemObject);
        }
    }
};
    
Cary.ui.TreeView.prototype.findItemByObject = function (parentItem, object)
{
    var item,
        i;

    for (i = 0; i < parentItem.subItems.length; ++ i)
    {
        if (parentItem.subItems [i].itemObject === object)
            return parentItem.subItems [i];

        item = this.findItemByObject (parentItem.subItems [i], object);

        if (item !== null)
            return item;
    }

    return null;
};

Cary.ui.TreeView.prototype.getSelectedItem = function ()
{
    return this.selectedItem;
};

Cary.ui.TreeView.prototype.selectItem = function (item)
{
    if (this.selectedItem !== null)
        this.selectedItem.itemObject.className = 'tvItem';

    this.selectedItem = item;

    if (item !== null)
        item.itemObject.className = 'tvSelectedItem';
};
    
Cary.ui.TreeView.prototype.onItemMouseMove = function (event)
{
    var item;
    
    if (Cary.tools.isNothing (event))
        event = window.event;

    item = this.findItemByObject (this.rootItem, event.target);

    item.tree.selectItem (item);            
};
    
Cary.ui.TreeView.prototype.onItemClick = function (event)
{
    var item;
    
    if (Cary.tools.isNothing (event))
        event = window.event;

    item = this.findItemByObject (this.rootItem, event.target);

    if (event.offsetX > 0)
    {
        item.tree.selectItem (item);

        if ('onItemClick' in this.desc && this.desc.onItemClick)
            this.desc.onItemClick (item);
    }
    else
    {
        if (item !== null && item.subItems.length > 0)
        {
            if (item.expanded)
                item.tree.collapseItem (item);
            else
                item.tree.expandItem (item);
        }
    }
};
    
Cary.ui.TreeView.prototype.onItemDblClick = function (event)
{
    var item;
    
    if (Cary.tools.isNothing (event))
        event = window.event;

    item = this.findItemByObject (this.rootItem, event.target);

    if (item !== null && 'onDblClick' in item)
        item.onDblClick (item);
}    ;

Cary.ui.ListView = function (desc, styles)
{
    this.items         = [];
    this.columnHeaders = [];
    this.selection     = -1;
    this.itemOffset    = 'itemOffset' in desc ? desc.itemOffset : null;
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.ListView.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.ListView.prototype.initialize = function ()
{
    var columnHeader;
    var i;
    var x;
    
    //Cary.ui.ListView.prototype.initialize.apply (this);
    
    this.htmlObject = document.createElement ('div');
    this.header     = document.createElement ('div');
    this.client     = document.createElement ('div');

    this.htmlObject.className = 'listView';
    this.header.className     = 'listViewHeader';
    this.client.className     = 'listViewClient';
    
    this.htmlObject.appendChild (this.header);
    this.htmlObject.appendChild (this.client);

    Cary.ui.Control.prototype.initialize.apply (this, arguments);

    for (i = 0, x = 1; i < this.desc.columns.length; ++ i)
    {
        var columnDesc = this.desc.columns [i];
        
        columnHeader = document.createElement ('div');
        
        columnHeader.className   = 'listViewColumnHeader';
        columnHeader.style.width = Cary.tools.int2pix (columnDesc.width);
        
        if ('headerLineHeight' in this.desc)
            columnHeader.style.lineHeight = Cary.tools.int2pix (this.desc.headerLineHeight);
        
        if ('htmlTitle' in columnDesc)
            columnHeader.innerHTML = columnDesc.htmlTitle;
        else if ('title' in columnDesc)
            columnHeader.innerText = columnDesc.title;
        //columnHeader.style.left  = Cary.tools.int2pix (x);
        
        if ('align' in columnDesc)
            columnHeader.style.textAlign = columnDesc.align;
        
        if ('onHeaderClick' in columnDesc)
            columnHeader.onclick = columnDesc.onHeaderClick;
        
        x += (columnDesc.width + 8);
        
        this.header.appendChild (columnHeader);
        
        this.columnHeaders.push (this.columnHeaders);
    }
    
    //this.client.style.top = Cary.tools.int2pix (this.header.offsetHeight);
};

Cary.ui.ListView.prototype.reverseItems = function ()
{
    var i;

    for (i = this.items.length - 1; i >= 0; -- i)
        this.client.removeChild (this.items [i].itemDiv);

    this.items.reverse ();

    for (i = 0; i < this.items.length; ++ i)
    {
        this.items [i].itemDiv.style.top = int2pix (i * 23 - 2);

        this.client.appendChild (this.items [i].itemDiv);
    }

    if (this.selection >= 0)
        this.selectItem (items.length - this.selection - 1);
};

Cary.ui.ListView.prototype.removeAllFrom = function (startIndex)
{
    var i;

    for (i = startIndex; i < this.items.length; ++ i)
        this.client.removeChild (this.items [i].itemDiv);

    this.items.splice (startIndex, 0xffffffff);
};
    
Cary.ui.ListView.prototype.addItem = function (columnText, data)
{
    return this.insertItem (columnText, data);
};

Cary.ui.ListView.prototype.setItemImage = function (item, column, imageSource, maxWidth, maxHeight)
{
    var image = document.createElement ('img');
    var i;
    
    image.src             = imageSource;
    image.style.overflowX = 'hidden';
    image.style.overflowY = 'hidden';
    image.style.margin    = '0px';
    image.style.padding   = '0px';
    
    if (Cary.tools.isNothing (maxWidth))
        maxWidth = this.desc.columns [column].width;
    
    if (Cary.tools.isNothing (maxHeight))
        maxHeight = item.itemColumns [column].offsetHeight;
    
    // Zoom out when needed
    if (image.naturalWidth > maxWidth || image.naturalHeight > maxHeight)
    {
        var ratioX = maxWidth / image.naturalWidth;
        var ratioY = maxHeight / image.naturalHeight;
        var ratio  = Math.min (ratioX, ratioY);
        
        image.style.width  = Cary.tools.int2pix (Math.round (image.naturalWidth * ratio));
        image.style.height = Cary.tools.int2pix (Math.round (image.naturalHeight * ratio));
    }
    
    item.itemColumns [column].appendChild (image);
};

Cary.ui.ListView.prototype.insertItem = function (columnText, data, index)
{
    var itemDiv;
    var itemColumns = [];
    var itemColumnDiv;
    var item;
    var i;
    var instance = this;
    var maxHeight;

    if (this.client.style.top === null || this.client.style.top === '')
    {
        var headerHeight = this.itemOffset ? this.itemOffset : (this.header.offsetHeight ? this.header.offsetHeight : 25);
        
        this.client.style.top = Cary.tools.int2pix (headerHeight);
        
        if ('height' in this.styles && typeof (this.styles.height) === 'number')
            this.client.style.height = Cary.tools.int2pix (this.styles.height - headerHeight);
    }
    
    itemDiv = document.createElement ('div');

    itemDiv.className = 'listViewItem';

    if (Cary.tools.isNothing (index) || index < 0 || index >= this.items.length)
    {
        this.client.appendChild (itemDiv);
    }
    else
    {
        this.client.insertBefore (itemDiv, this.items [index].itemDiv);
    }

    for (i = maxHeight = 0, x = 3; i < this.desc.columns.length; ++ i)
    {
        itemColumnDiv = document.createElement ('div');

        itemColumnDiv.className   = 'listViewItemColumn';
        itemColumnDiv.style.width = Cary.tools.int2pix (this.desc.columns [i].width);
        itemColumnDiv.innerText   = i < columnText.length ? columnText [i] : '';
        itemColumnDiv.onclick     = function (event) { instance.onClickItem (event, this); };
        itemColumnDiv.ondblclick  = function (event) { instance.onDblClickItem (event, this); };

        if ('align' in this.desc.columns [i])
            itemColumnDiv.style.textAlign = this.desc.columns [i].align;
        
        // Prevent "empty" subitem
        if (itemColumnDiv.innerText === '' || itemColumnDiv.innerText === null)
        {
            itemColumnDiv.innerText   = '*';
            itemColumnDiv.style.color = 'transparent';
        }
        
        x += (this.desc.columns [i].width + 8);

        itemDiv.appendChild (itemColumnDiv);

        itemColumns.push (itemColumnDiv);
        
        if (itemColumnDiv.clientHeight > maxHeight)
            maxHeight = itemColumnDiv.clientHeight;
    }

    // Extend height of subitems that are less high than maxHeight
    itemColumns.forEach (function (itemColumn)
                         {
                             //if (itemColumn.clientHeight < maxHeight)
                                 itemColumn.style.height = Cary.tools.int2pix (maxHeight - 4);
                         });
    
    item = { itemDiv: itemDiv, itemColumns: itemColumns, data: data };

    if (Cary.tools.isNothing (index) || index < 0 || index >= this.items.length)
        this.items.push (item);
    else
        this.items.splice (index, 0, item);

    return item;
};

Cary.ui.ListView.prototype.selectItem = function (index)
{
    if (index < 0)
    {
        var i, j;

        this.selection = -1;

        for (i = 0; i < this.items.length; ++ i)
        {
            for (j = 0; j < this.items [i].itemColumns.length; ++ j)
                this.items [i].itemColumns [j].className = 'listViewItemColumn';
        }
    }
    else if (index < this.items.length)
    {
        var i, j;

        this.selection = index;

        if (this.items [index].itemDiv.offsetTop < this.client.scrollTop)
            this.client.scrollTop = this.items [index].itemDiv.offsetTop;
        else if (this.items [index].itemDiv.offsetTop > (this.client.scrollTop + this.client.offsetHeight))
            this.client.scrollTop = this.items [index].itemDiv.offsetTop;

        for (i = 0; i < this.items.length; ++ i)
        {
            for (j = 0; j < this.items [i].itemColumns.length; ++ j)
                this.items [i].itemColumns [j].className = (i === index) ? 'listViewItemColumnSelected' : 'listViewItemColumn';
        }

        if (!Cary.tools.isNothing (this.desc.onSelect))
            this.desc.onSelect (index, this.items [index].data);
    }
};

Cary.ui.ListView.prototype.onClickItem = function (event, itemDiv)
{
    var i, j;

    for (i = 0; i < this.items.length; ++ i)
    {
        for (j = 0; j < this.items [i].itemColumns.length; ++ j)
        {
            if (this.items [i].itemColumns [j] === itemDiv)
            {
                this.selectItem (i);

                if (!Cary.tools.isNothing (this.desc.columns [j].onItemClick))
                    this.desc.columns [j].onItemClick (i, j, this.items [i]);

                return;
            }
        }
    }
};

Cary.ui.ListView.prototype.onDblClickItem = function (event, itemDiv)
{
    var i, j;

    for (i = 0; i < this.items.length; ++ i)
    {
        for (j = 0; j < this.items [i].itemColumns.length; ++ j)
        {
            if (this.items [i].itemColumns [j] === itemDiv)
            {
                this.selectItem (i);

                if (!Cary.tools.isNothing (this.desc.columns [j].onItemDblClick))
                    this.desc.columns [j].onItemDblClick (i, j, this.items [i]);

                return;
            }
        }
    }
};

Cary.ui.ListView.prototype.scrollToBottom = function ()
{
    this.client.scrollTop = this.client.scrollHeight;
};
 
Cary.ui.ListView.prototype.getItemCount = function ()
{
    return this.items.length;
};

Cary.ui.ListView.prototype.setItemText = function (itemIndex, columnIndex, text)
{
    this.items [itemIndex].itemColumns [columnIndex].innerText = text;
    
    if (text !== null && text !== '' && this.items [itemIndex].itemColumns [columnIndex].style.color === 'transparent')
        this.items [itemIndex].itemColumns [columnIndex].style.color = null;
};

Cary.ui.ListView.prototype.getItemText = function (itemIndex, columnIndex)
{
    return this.items [itemIndex].itemColumns [columnIndex].innerText;
};

Cary.ui.ListView.prototype.getItemData = function (itemIndex)
{
    return this.items [itemIndex].data;
};

Cary.ui.ListView.prototype.setItemData = function (itemIndex, data)
{
    this.items [itemIndex].data = data;
};

Cary.ui.ListView.prototype.enumItems = function (callback)
{
    this.items.forEach (callback);
};

Cary.ui.ListView.prototype.getSelectedItem = function ()
{
    return this.selection;
};

Cary.ui.ListView.prototype.removeAllItems = function ()
{
    this.items = [];

    while (this.client.firstChild)
        this.client.removeChild (this.client.firstChild);
};

Cary.ui.ListView.prototype.removeItem = function (index)
{
    if (index >= 0 && index < this.items.length)
    {
        var i;

        for (i = 0; i < this.items [index].itemColumns.length; ++ i)
            this.items [index].itemDiv.removeChild (this.items [index].itemColumns [i]);

        this.client.removeChild (this.items [index].itemDiv);

        this.items.splice (index, 1);

        for (i = index; i < this.items.length; ++ i)
            this.items [i].itemDiv.style.top = Cary.tools.int2pix (i * 23 - 2);
        
        this.selection = -1;
    }
};

Cary.ui.ListView.prototype.setWidth = function (width)
{
    this.htmlObject.style.width  = Cary.tools.int2pix (width);
    this.htmlObject.style.header = Cary.tools.int2pix (width);
    this.htmlObject.style.client = Cary.tools.int2pix (width);
};
    

Cary.ui.ListBox = function (desc, styles)
{
    this.items       = [];
    this.comboBox    = 'comboBox' in desc && desc.comboBox;
    this.onItemClick = 'onItemClick' in desc ? desc.onItemClick : null;
    
    if (!('className' in desc))
        desc.className = 'listBox';
    
    Cary.ui.Control.apply (this, arguments);    
};

Cary.ui.ListBox.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.ListBox.prototype.initialize = function ()
{
    this.htmlObject           = document.createElement ('select');
    this.htmlObject.className = 'listBox wpListBox';
    this.htmlObject.size      = this.comboBox ? 1 : 2;
    
    if ('onItemSelect' in this.desc)
        this.htmlObject.onchange = this.desc.onItemSelect;
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
    
    if ('items' in this.desc)
    {
        var instance = this;
        
        this.desc.items.forEach (function (item) { instance.addItem (item.text, item.data); });
    }
};

Cary.ui.ListBox.prototype.getCount = function ()
{
    return this.items.length;
};

Cary.ui.ListBox.prototype.getSelectedData = function ()
{
    var result;
    var selection = this.getCurSel ();

    if (selection >= 0)
        result = this.getItemData (selection);
    else
        result = null;

    return result;
};

Cary.ui.ListBox.prototype.addItem = function (text, data, selectNewItem)
{
    var itemObject = document.createElement ('option');
    var instance   = this;

    if (Cary.tools.isNothing (selectNewItem))
        selectNewItem = false;
    
    itemObject.className = 'listBoxItem';
    itemObject.onselect  = function ()
                           {
                                var i, selection;

                                for (i = 0, selection = -1; i < instance.htmlObject.options.length; ++ i)
                                {
                                   if (this === this.parentElement.options [i])
                                   {
                                       selection = i; break;
                                   }
                                }

                                if (selection >= 0)
                                {
                                    instance.setCurSel (selection);

                                    if (instance.onItemClick !== null)
                                        instance.onItemClick (selection);
                                }
                           };
    itemObject.onclick   = itemObject.onselect;

    if (this.htmlObject.style.color)
        itemObject.style.color = this.htmlObject.style.color;

    this.htmlObject.appendChild (itemObject);

    if (!this.comboBox)
        this.htmlObject.size = this.items.length > 0 ? this.items.length + 1 : 2;

    itemObject.innerText = text;

    this.items.push ({ itemObject: itemObject, data: data });

    if (selectNewItem)
        this.setCurSel (this.items.length - 1);
    
    return this.items.length - 1;
};

Cary.ui.ListBox.prototype.removeItem = function (index)
{
    this.items.splice (index, 1);

    this.htmlObject.options.remove (index);
};

Cary.ui.ListBox.prototype.setCurSel = function (selection)
{
    this.htmlObject.selectedIndex = selection;
};

Cary.ui.ListBox.prototype.getCurSel = function ()
{
    return this.htmlObject.selectedIndex;
};

Cary.ui.ListBox.prototype.getItemData = function (index)
{
    return (index >= 0 && index < this.items.length) ? this.items [index].data : null;
};

Cary.ui.ListBox.prototype.setItemData = function (index, data)
{
    if (index >= 0 && index < this.items.length)
        this.items [index].data = data;
};

Cary.ui.ListBox.prototype.getItemText = function (index)
{
    return (index >= 0 && index < this.items.length) ? this.items [index].itemObject.innerText : null;
};

Cary.ui.ListBox.prototype.getSelectedText = function ()
{
    return this.htmlObject.selectedIndex >= 0 ? this.items [this.htmlObject.selectedIndex].itemObject.innerText : null;
};

Cary.ui.ListBox.prototype.setItemText = function (index, text)
{
    if (index >= 0 && index < this.items.length)
        this.items [index].itemObject.innerText = text;
};

Cary.ui.ListBox.prototype.resetContent = function ()
{
    while (this.htmlObject.options.length > 0)
        this.htmlObject.options.remove (0);
};

Cary.ui.ListBox.prototype.selectByData = function (data)
{
    var i;
    
    for (i = 0; i < this.items.length; ++ i)
    {
        if (this.items [i].data === data)
        {
            this.setCurSel (i); break;
        }
    }
};
Cary.ui.Browser = function (desc, styles)
{
    if (!('className' in desc))
        desc.className = 'static';
    
    Cary.ui.Control.apply (this, arguments);    
};

Cary.ui.Browser.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.Browser.prototype.initialize = function ()
{
    this.htmlObject               = document.createElement ('iframe');
    this.htmlObject.src           = 'source' in this.desc ? this.desc.source : 'about:blank';
    //this.htmlObject.sandbox       = '';
    this.htmlObject.innerHtml     = 'Your browser does not support IFRAME tag';
    this.htmlObject.style.padding = '0px';
    this.htmlObject.style.margin  = '0px';
    this.htmlObject.style.borderWidth = '0px';
        
    if ('scrollable' in this.desc && this.desc.scrollable)
    {
        this.htmlObject.style.overflowX = 'auto';
        this.htmlObject.style.overflowY = 'auto';
    }

    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};


Cary.ui.BrowseBox = function (desc)
{
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.BrowseBox.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.BrowseBox.prototype.initialize = function ()
{
    this.htmlObject   = document.createElement ('div');
    this.editBox      = document.createElement ('input');
    this.browseButton = document.createElement ('button');

    this.editBox.type           = 'text';
    this.editBox.className      = 'editBox';
    this.browseButton.className = 'browseButton';
    this.browseButton.innerText = Cary.symbols.magnifier1;

    this.editBox.style.display = 'inline';
    this.editBox.style.height  = '100%';
    
    if ('width' in this.styles && typeof (this.styles.width) === 'number')
        this.editBox.style.width = Cary.tools.int2pix (this.styles.width - 50);
    
    if ('onBrowse' in this.desc)
        this.browseButton.onclick = this.desc.onBrowse;

    this.htmlObject.appendChild (this.editBox);
    this.htmlObject.appendChild (this.browseButton);
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};

Cary.ui.BrowseBox.prototype.getValue = function ()
{
    return this.editBox.value;
};
    
Cary.ui.BrowseBox.prototype.setValue = function (value)
{
    this.editBox.value = value;
};

Cary.ui.CheckBox = function (desc, styles)
{
    if (!('className' in desc))
        desc.className = 'checkBox';
    
    Cary.ui.Control.apply (this, arguments);    
};

Cary.ui.CheckBox.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.CheckBox.prototype.initialize = function ()
{
    var instance = this;
    
    this.htmlObject = document.createElement ('div');
    this.checkMark  = document.createElement ('div');
    this.checked    = 'checked' in this.desc && this.desc.checked;

    this.htmlObject.className = 'checkBox';
    this.htmlObject.innerText = 'text' in this.desc ? this.desc.text : '';
    this.htmlObject.onclick   = toggle;
    this.checkMark.className  = 'checkMark';
    this.checkMark.innerText  = this.checked ? Cary.symbols.checked : Cary.symbols.unchecked;
    //this.checkMark.onclick    = toggle;
  
    this.htmlObject.appendChild (this.checkMark);
    
    Cary.ui.Control.prototype.initialize.apply (this, arguments);
    
    function toggle ()
    {
        instance.checked = !instance.checked;
        
        if ('onChange' in instance.desc)
            instance.desc.onChange (instance.checked);
        
        instance.checkMark.innerText  = instance.checked ? Cary.symbols.checked : Cary.symbols.unchecked;
    }
};

Cary.ui.CheckBox.prototype.getValue = function ()
{
    return this.checked;
};

Cary.ui.CheckBox.prototype.setValue = function (value)
{
    this.checked = value;
    
    this.checkMark.innerText  = this.checked ? Cary.symbols.checked : Cary.symbols.unchecked;
};

Cary.ui.Details = function (desc, styles)
{
    this.backupContent = null;
    
    if (!('className' in desc))
        desc.className = 'details';
    
    Cary.ui.Control.apply (this, arguments);
};

Cary.ui.Details.prototype = Object.create (Cary.ui.Control.prototype);

Cary.ui.Details.prototype.initialize = function ()
{
    this.htmlObject = document.createElement ('div');
    
    this.htmlObject.className = this.desc.className;

    Cary.ui.Control.prototype.initialize.apply (this, arguments);
};

Cary.ui.Details.prototype.addItem = function (name, details)
{
    var itemName    = document.createElement ('span');
    var itemDetails = document.createElement ('span');
    var paragraph   = document.createElement ('p');
    
    itemName.style.fontWeight = 'bold';
    itemName.innerText        = name + ': ';
    
    itemDetails.style.fontWeight = 'regular';
    itemDetails.innerText        = details;
    
    this.htmlObject.appendChild (itemName);
    this.htmlObject.appendChild (itemDetails);
    this.htmlObject.appendChild (paragraph);
};

Cary.ui.Details.prototype.clear = function ()
{
    this.htmlObject.innerHTML = null;
};

Cary.ui.Details.prototype.backup = function (enableMultiLevel)
{
    if (Cary.tools.isNothing (enableMultiLevel))
        enableMultiLevel = false;
    
    if (enableMultiLevel)
    {
        // Stack-like mode
        if (this.backupContent === null)
            this.backupContent = [];
        
        this.backupContent.push (this.htmlObject.innerHTML);
    }
    else if (this.backupContent === null)
    {
        // Scalar mode
        this.backupContent = this.htmlObject.innerHTML;
    }
};

Cary.ui.Details.prototype.restore = function ()
{
    if (Array.isArray (this.backupContent))
    {
        // Stack-like mode
        if (this.backupContent.length > 0)
            this.htmlObject.innerHTML = this.backupContent.splice (this.backupContent.length - 1, 1);
    }
    else if (this.backupContent)
    {
        // Scalar mode
        this.htmlObject.innerHTML = this.backupContent;
        
        this.backupContent = null;
    }
};

function CalendarControl (desc, date)
{
    var parent;
    var control;
    var year;
    var month;
    var weekDay;
    var monthDay;
    var week;
    var selectedDate;
    var minDate = 'min' in desc ? desc.min : new Date (0);
    var maxDate = 'max' in desc ? desc.max : new Date ();

    if (isNaN (date.getTime ()))
        date = new Date ();
    
    minDate.setHours (0);
    minDate.setMinutes (0);
    minDate.setSeconds (0);
    minDate.setMilliseconds (0);
    
    maxDate.setHours (23);
    maxDate.setMinutes (59);
    maxDate.setSeconds (59);
    maxDate.setMilliseconds (999);
    
    CalendarControl.instance = this;
    
    if (typeof (desc) === 'undefined')
        desc = {};

    if (typeof (date) === 'undefined')
        date = new Date ();

    selectedDate = date;

    getDateProperties ();

    if ('parent' in desc)
        parent = desc.parent;
    else
        parent = document.getElementsByTagName ('body') [0];

    control = createControl (desc);

    popupateCalendar ();

    document.getElementById ('prevMonth').onclick = goToPrevMonth;
    document.getElementById ('nextMonth').onclick = goToNextMonth;

    this.close  = close;
    this.setMin = setMin;
    this.setMax = setMax;

    function setMin (date)
    {
        minDate = date;
    }
    
    function setMax (date)
    {
        maxDate = date;
    }
    
    function close ()
    {
        parent.removeChild (control);
        
        CalendarControl.instance = null;
    }

    function createControl (desc)
    {
        var parentElement = null;
        var container     = document.createElement ('div');
        var monthSelector = document.createElement ('div');
        var goToPrevMonth = document.createElement ('button');
        var goToNextMonth = document.createElement ('button');
        var monthName     = document.createElement ('div');
        var weekHeader    = document.createElement ('div');
        var closeButton   = document.createElement ('button');
        var daysOfWeek    = [];
        var weeks         = [];
        var dayOfWeek;
        var i;
        var j;

        if ('parentID' in desc)
            parentElement = document.getElementById (desc.parent);
        else if ('parent' in desc)
            parentElement = desc.parent;
        else
            parentElement = document.getElementsByTagName ('body') [0];

        container.className = 'calendar';
        container.onselectstart = function () { return false; };

        if ('position' in desc)
        {
            container.style.position = 'absolute';
            container.style.left     = desc.position.x.toString () + 'px';
            container.style.top      = desc.position.y.toString () + 'px';
        }

        monthSelector.className = 'monthSelector';

        goToPrevMonth.className = 'goToPrevMonth';
        goToPrevMonth.id        = 'prevMonth';
        goToPrevMonth.innerText = '◄';

        goToNextMonth.className = 'goToNextMonth';
        goToNextMonth.id        = 'nextMonth';
        goToNextMonth.innerText = '►';

        closeButton.innerText = 'X';
        closeButton.className = 'closeButton';
        closeButton.onclick   = close;
        
        monthName.className = 'monthName';
        monthName.id        = 'monthName';
        monthName.innerText = 'August 2016';

        monthSelector.appendChild (monthName);
        monthSelector.appendChild (goToPrevMonth);
        monthSelector.appendChild (closeButton);
        monthSelector.appendChild (goToNextMonth);

        weekHeader.className = 'weekHeader';

        for (i = 0; i < 7; ++ i)
        {
            daysOfWeek [i] = document.createElement ('div');

            daysOfWeek [i].className = 'dayOfWeek';
            daysOfWeek [i].innerText = CalendarControl.weekDays [i];

            weekHeader.appendChild (daysOfWeek [i]);
        }

        container.appendChild (monthSelector);
        container.appendChild (weekHeader);

        for (i = 0; i < 6; ++ i)
        {
            weeks [i] = document.createElement ('div');

            weeks [i].className = 'week';
            weeks [i].id        = 'week' + (i + 1).toString ();

            container.appendChild (weeks [i]);

            for (j = 0; j < 7; ++ j)
            {
                dayOfWeek = document.createElement ('div');

                dayOfWeek.className = 'day';
                dayOfWeek.id        = 'day' + (i + 1).toString () + (j + 1).toString ();

                weeks [i].appendChild (dayOfWeek);
            }
        }

        parentElement.appendChild (container);

        return container;
        //return document.getElementById ('calendar');
    }

    function getDateProperties ()
    {
        year     = date.getFullYear ();
        month    = date.getMonth ();
        weekDay  = date.getDay ();                  // Zero-based
        monthDay = date.getDate ();
        week     = Math.floor ((date - weekDay) / 7);   // Zero-based
    }

    function isLeapYear (yearToCheck)
    {
        return ((yearToCheck - 1980) % 4) === 0;
    }

    function getMaxDay (month)
    {
        var result;

        switch (month)
        {
            case 0:
            case 2:
            case 4:
            case 6:
            case 7:
            case 9:
            case 11:
                result = 31; break;

            case 1:
                result = isLeapYear (year) ? 29 : 28; break;

            case 3:
            case 5:
            case 8:
            case 10:
                result = 30; break;

            default:
                result = 0;
        }

        return result;
    }

    function goToPrevMonth ()
    {
        var monthName = document.getElementById ('monthName');

        if (month > 0)
        {
            -- month;
        }
        else
        {
            month = 11;

            -- year;
        }

        monthName.innerText = CalendarControl.monthNames [month] + ' ' + year.toString ();

        popupateCalendar ();
    }

    function goToNextMonth ()
    {
        var monthName = document.getElementById ('monthName');

        if (month < 11)
        {
            ++ month;
        }
        else
        {
            month = 0;

            ++ year;
        }

        monthName.innerText = CalendarControl.monthNames [month] + ' ' + year.toString ();

        popupateCalendar ();
    }

    function popupateCalendar ()
    {
        var weekNo,
            dayNo,
            weekDayNo,
            beginWeekDayNo,
            endWeekDayNo,
            beginDate,
            endDate,
            maxDay,
            curDay,
            prevMonth,
            nextMonth,
            maxPrevMonthDay,
            maxNextMonthDay,
            id,
            dayElement,
            curDate;

        nextMonth       = month < 11 ? month + 1 : 0;
        prevMonth       = month > 0 ? month - 1 : 11;
        maxDay          = getMaxDay (month);
        maxPrevMonthDay = getMaxDay (prevMonth);
        maxNextMonthDay = getMaxDay (nextMonth);
        beginDate       = new Date (year, month, 1, 0, 0, 0);
        endDate         = new Date (year, month, maxDay, 0, 0, 0);
        beginWeekDayNo  = beginDate.getDay ();
        endWeekDayNo    = endDate.getDay ();

        monthName.innerText = CalendarControl.monthNames [month] + ' ' + year.toString ();

        for (weekNo = 1; weekNo <= 6; ++ weekNo)
        {
            for (weekDayNo = 0; weekDayNo < 7; ++ weekDayNo)
            {
                id         = 'day' + weekNo.toString () + (weekDayNo + 1).toString ();
                dayElement = document.getElementById (id);

                dayElement.onclick = null;
                
                dayNo = (weekNo - 1) * 7 + weekDayNo - beginWeekDayNo + 1;
                
                curDate = new Date (year, month, dayNo, 0, 0, 0);
                
                if (dayNo <= 0)
                {
                    dayNo += maxPrevMonthDay;

                    dayElement.className = 'invalidDay';
                }
                else if (dayNo > maxDay)
                {
                    dayNo -= maxDay;

                    dayElement.className = 'invalidDay';
                }
                else if (year === selectedDate.getFullYear () && month === selectedDate.getMonth () && dayNo === selectedDate.getDate ())
                {
                    dayElement.className = 'selectedDay';

                    if ('onSelect' in desc)
                        dayElement.onclick = onSelectableDayClick;
                }
                else if ((minDate === null || minDate <= curDate) && (maxDate === null || maxDate >= curDate))
                {
                    dayElement.className = 'day';

                    if ('onSelect' in desc)
                        dayElement.onclick = onSelectableDayClick;
                }
                else
                {
                    dayElement.className = 'disabledDay';
                }

                dayElement.innerText = dayNo.toString ();
        
                function onSelectableDayClick ()
                {
                    var wn = parseInt (this.id [3]);
                    var wd = parseInt (this.id [4]);
                    var dn = (wn - 1) * 7 + (wd - 1) - beginWeekDayNo + 1;

                    desc.onSelect (new Date (year, month, dn, 0, 0, 0));
                }
            }
        }
    }
}

CalendarControl.monthNames = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
                               'October', 'November', 'December' ];

CalendarControl.weekDays = [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ];

CalendarControl.instance = null;
Cary.ui.DateHourBox = function (desc)
{
    var control    = document.createElement ('div'),
        datePicker = document.createElement ('input'),
        hourBox    = document.createElement ('input');
    var parent     = getCtlParent (desc);
    var dateTime   = getCtlDescField (desc, 'value');
    var minDate    = 'min' in desc ? desc.min : null;
    var maxDate    = 'max' in desc ? desc.max : null;
    var onChange   = 'onChange' in desc ? desc.onChange : null;
    var calendCtrl = null;
    var utcMode    = 'utc' in desc ? desc.utc : true;
    var defHours   = 'defHours' in desc ? desc.defHours : null;

    control.className = getClassName ('dateTimeBox');
    
    datePicker.type        = 'text';
    datePicker.className   = getClassName ('dateBox dateBox2', 'dpExtraClass');
    datePicker.id          = 'id' in desc ? desc.id + '_date' : null;
    datePicker.onclick     = processDateClick;

    hourBox.type      = 'text';
    hourBox.className = getClassName ('hourBox', 'hbExtraClass');
    hourBox.id        = 'id' in desc ? desc.id + '_hour' : null;
    hourBox.onclick   = function (event)
                        {
                            new HourSelector ({ parent: control, x: event.clientX, y: event.clientY, value: parseInt (hourBox.value), utc: utcMode,
                                                onSelect: function (value)
                                                          {
                                                              hourBox.value = value.toString ();
                                                              
                                                              if (onChange)
                                                                  onChange ();
                                                          }});
                        };

    if (dateTime !== null)
    {
        var date = utcMode ? formatDateUTC (dateTime) : formatDateLocal (dateTime);
        var hour = utcMode ? formatHourUTC (dateTime) : formatHourLocal (dateTime);
        
        datePicker.value = date;
        hourBox.value    = hour.toString ();
    }
    
    control.appendChild (datePicker);
    control.appendChild (hourBox);
    parent.appendChild (control);
    
    this.htmlObject = control;
    this.setValue   = setValue;
    this.getValue   = getValue;
    this.setMin     = setMin;
    this.setMax     = setMax;
    this.enable     = enable;
    
    enable (!(('disabled' in desc) && desc.disabled));

    function enable (enabled)
    {
        var disabled = enabled ? null : 'disabled';
        
        control.disabled    = disabled;
        datePicker.disabled = disabled;
        hourBox.disabled    = disabled;
    }
    
    function setMin (date)
    {
        minDate = date;
        
        if (calendCtrl !== null)
            calendCtrl.setMin (date);
    }
    
    function setMax (date)
    {
        maxDate = date;
        
        if (calendCtrl !== null)
            calendCtrl.setMax (date);
    }
    
    function processDateClick (event)
    {
        var x;
        var y;
        var windowWidth  = window.innerWidth;
        var windowHeight = window.innerHeight;
        var calendarDesc;
        
        if (isUndefinedOrNull (event))
            event = window.event;
        
        x = event.clientX;
        y = event.clientY;
        
        if ((x + 220) > windowWidth)
            x = windowWidth - 220;
        
        if ((y + 180) > windowHeight)
            y = windowHeight - 180;

        if (CalendarControl.instance !== null)
            CalendarControl.instance.close ();

        calendarDesc = { position: { x: x, y: y }, utc: utcMode,
                         onSelect: function (date)
                                   {
                                        datePicker.value = formatDateLocal (date);

                                        CalendarControl.instance.close ();
                                        
                                        if ('onDateChanged' in desc)
                                            desc.onDateChanged (date);
                                   } };
            
        if (minDate !== null)
            calendarDesc.min = minDate;
        
        if (maxDate !== null)
            calendarDesc.max = maxDate;
        
        calendCtrl = new CalendarControl (calendarDesc, this.value === '' ? new Date () : stringToDateUTC (this.value /*+ 'T00:00:00Z'*/));
    }
    
    function getClassName (defaultClass, classKey)
    {
        if (!classKey)
            classKey = 'extraClass';
        
        return classKey in desc ? defaultClass + ' ' + desc [classKey] : defaultClass;
    }
    
    function getValue ()
    {
        var value = datePicker.value;
        var date  = stringToDateUTC (value /*+ 'T00:00:00Z'*/);

        if (date !== null)
        {
            var hours = hourBox.value;
            
            if ((hours === null || hours === '') && defHours !== null)
                hours = defHours.toString ();
            
            if (utcMode)
                date.setUTCHours (parseInt (hours));
            else
                date.setHours (parseInt (hours));
        }
        
        return date;
    }
    
    function setValue (value)
    {
        var date = value ? (utcMode ? formatDateUTC (value) : formatDateLocal (value)) : null;
        var hour = value ? (utcMode ? formatHourUTC (value) : formatHourLocal (value)) : null;
        
        datePicker.value = date;
        hourBox.value    = hour;
    }
};


Cary.ui.CoordEditWnd = function (parent, data, callbacks)
{
    this.callbacks   = Cary.tools.isNothing (callbacks) ? {} : callbacks;
    this.data        = Cary.tools.isNothing (data) ? {} : data;
    this.mode        = 'mode' in data ? data.mode : CoordEditWnd.modes.LAT;
    this.value       = 'value' in data ? data.value : '';
    
    if (parent === null)
        parent = document.getElementsByTagName ('body') [0];
    
    Cary.ui.Window.apply (this, [{ position: { hcenter: true, vcenter: true, width: 195, height: 110, absolute: true }, 
                                 title: 'Enter the ' + (this.mode === Cary.ui.CoordEditWnd.modes.LAT ? 'latitude' : 'longitude'), parent: parent, visible: true }]);
};

Cary.ui.CoordEditWnd.modes = { LAT: 1, LON: 2 };

Cary.ui.CoordEditWnd.prototype = Object.create (Cary.ui.Window.prototype);

Cary.ui.CoordEditWnd.prototype.onInitialize = function ()
{
    var buttonBlock = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, anchor: Cary.ui.anchor.BOTTOM });
    var editBlock   = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, anchor: Cary.ui.anchor.TOP }, { padding: 10 });
    var buttonStyle = { width: 70, height: 30, float: 'right' };
    var instance    = this;
    var maxValue    = this.mode === Cary.ui.CoordEditWnd.modes.LAT ? 90 : 180;
    var absValue    = Math.abs (this.value);
    var deg         = Math.floor (absValue);
    var min         = Cary.tools.round ((absValue - deg) * 60, 3);
    var items       = this.mode === Cary.ui.CoordEditWnd.modes.LAT ? [{ text: 'N' }, { text: 'S' }] : [{ text: 'E' }, { text: 'W' }];
    var degCtl      = new Cary.ui.EditBox ({ parent: editBlock.htmlObject, numeric: true, min: 0, max: maxValue, visible: true, value: deg }, { display: 'inline', float: 'left', 'margin-right': 10, width: 50 });
    var minCtl      = new Cary.ui.EditBox ({ parent: editBlock.htmlObject, numeric: true, float: true, min: 0, max: 59.999, visible: true, value: min, step: 1 }, { display: 'inline', float: 'left', 'margin-right': 10, width: 80 });
    var sideCtl     = new Cary.ui.ListBox ({ parent: editBlock.htmlObject, comboBox: true, visible: true, items: items }, { display: 'inline', float: 'left', width: 40 });
    
    if (this.value < 0)
        sideCtl.setCurSel (1);
    
    new Cary.ui.Button ({ text: 'Cancel', parent: buttonBlock.htmlObject, visible: true, onClick: forceClose }, buttonStyle);
    new Cary.ui.Button ({ text: 'OK', parent: buttonBlock.htmlObject, visible: true, onClick: onOk }, buttonStyle);
    
    function forceClose ()
    {
        instance.close ();
        
        if ('onClose' in instance.callbacks)
            instance.callbacks.onClose ();
    }
    
    function onOk ()
    {
        var value = degCtl.getValue () + parseFloat (minCtl.getValue () / 60);
        
        if (sideCtl.getCurSel () > 0)
            value = - value;
        
        instance.close (true);
        
        if ('onOk' in instance.callbacks)
            instance.callbacks.onOk (value);
    }
};


Cary.ui.PositionEditWnd = function (parent, data, callbacks)
{
    this.callbacks   = Cary.tools.isNothing (callbacks) ? {} : callbacks;
    this.data        = Cary.tools.isNothing (data) ? { lat: null, lon: null } : data;
    this.lat         = this.data.lat;
    this.lon         = this.data.lon;
    
    if (parent === null)
        parent = document.getElementsByTagName ('body') [0];
    
    Cary.ui.Window.apply (this, [{ position: { hcenter: true, vcenter: true, width: 195, height: 140, absolute: true }, title: 'Enter the position', parent: parent, visible: true }]);
};

Cary.ui.PositionEditWnd.prototype = Object.create (Cary.ui.Window.prototype);

Cary.ui.PositionEditWnd.prototype.onInitialize = function ()
{
    var buttonBlock = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, anchor: Cary.ui.anchor.BOTTOM });
    var latBlock    = new Cary.ui.ControlBlock ({ parent: this.client, visible: true }, { padding: 10, 'margin-bottom': 15 });
    var lonBlock    = new Cary.ui.ControlBlock ({ parent: this.client, visible: true }, { padding: 10, 'margin-bottom': 15 });
    var buttonStyle = { width: 70, height: 30, float: 'right' };
    var instance    = this;
    var absLat      = Math.abs (this.lat);
    var absLon      = Math.abs (this.lon);
    var latDeg      = Math.floor (absLat);
    var lonDeg      = Math.floor (absLon);
    var latMin      = Cary.tools.round ((absLat - latDeg) * 60, 3);
    var lonMin      = Cary.tools.round ((absLon - lonDeg) * 60, 3);
    var latItems    = [{ text: 'N' }, { text: 'S' }];
    var lonItems    = [{ text: 'E' }, { text: 'W' }];
    var latDegCtl   = new Cary.ui.EditBox ({ parent: latBlock.htmlObject, numeric: true, min: 0, max: 90, visible: true, value: latDeg }, { display: 'inline', float: 'left', 'margin-right': 10, width: 50 });
    var lonDegCtl   = new Cary.ui.EditBox ({ parent: lonBlock.htmlObject, numeric: true, min: 0, max: 90, visible: true, value: lonDeg }, { display: 'inline', float: 'left', 'margin-right': 10, width: 50 });
    var latMinCtl   = new Cary.ui.EditBox ({ parent: latBlock.htmlObject, numeric: true, float: true, min: 0, max: 59.999, visible: true, value: latMin, step: 1 }, { display: 'inline', float: 'left', 'margin-right': 10, width: 80 });
    var lonMinCtl   = new Cary.ui.EditBox ({ parent: lonBlock.htmlObject, numeric: true, float: true, min: 0, max: 59.999, visible: true, value: lonMin, step: 1 }, { display: 'inline', float: 'left', 'margin-right': 10, width: 80 });
    var latSideCtl  = new Cary.ui.ListBox ({ parent: latBlock.htmlObject, comboBox: true, visible: true, items: latItems }, { display: 'inline', float: 'left', width: 40 });
    var lonSideCtl  = new Cary.ui.ListBox ({ parent: lonBlock.htmlObject, comboBox: true, visible: true, items: lonItems }, { display: 'inline', float: 'left', width: 40 });
    
    if (Cary.tools.isNothing (this.lat) || Cary.tools.isNothing (this.lon))
    {
        latDegCtl.setValue (null);
        latMinCtl.setValue (null);
        lonDegCtl.setValue (null);
        lonMinCtl.setValue (null);
    }
    
    if (this.lat < 0)
        latSideCtl.setCurSel (1);
    
    if (this.lon < 0)
        lonSideCtl.setCurSel (1);
    
    new Cary.ui.Button ({ text: 'Cancel', parent: buttonBlock.htmlObject, visible: true, onClick: forceClose }, buttonStyle);
    new Cary.ui.Button ({ text: 'OK', parent: buttonBlock.htmlObject, visible: true, onClick: onOk }, buttonStyle);
    
    function forceClose ()
    {
        instance.close ();
        
        if ('onClose' in instance.callbacks)
            instance.callbacks.onClose ();
    }
    
    function onOk ()
    {
        var lat = latDegCtl.getValue () + parseFloat (latMinCtl.getValue () / 60);
        var lon = lonDegCtl.getValue () + parseFloat (lonMinCtl.getValue () / 60);
        
        if (latSideCtl.getCurSel () > 0)
            lat = - lat;
        
        if (lonSideCtl.getCurSel () > 0)
            lon = - lon;
        
        instance.close (true);
        
        if ('onOk' in instance.callbacks)
            instance.callbacks.onOk ({ lat: lat, lon: lon });
    }
};


Cary.ui.UserPolylinePropsWnd = function (parent, object, callbacks)
{
    this.callbacks   = Cary.tools.isNothing (callbacks) ? {} : callbacks;
    this.object      = object;
    this.ctlBlkStyle = { padding: 0, 'padding-left': 10, 'margin-bottom': 8, 'margin-top': 8, height: 25, 'text-align': 'left', 'line-height': 25, 'font-size': 17 };
    
    if (parent === null)
        parent = document.getElementsByTagName ('body') [0];
    
    Cary.ui.Window.apply (this, [{ position: { hcenter: true, vcenter: true, width: 280, height: 220, absolute: true }, title: stringTable.polylineProps, parent: parent, visible: true }]);
};

Cary.ui.UserPolylinePropsWnd.prototype = Object.create (Cary.ui.Window.prototype);

Cary.ui.UserPolylinePropsWnd.prototype.onInitialize = function ()
{
    var styleItems  = [{ text: stringTable.solid, data: Cary.userObjects.lineStyles.SOLID }, { text: stringTable.dash, data: Cary.userObjects.lineStyles.DASH }, { text: stringTable.dot, data: Cary.userObjects.lineStyles.DOT } ];
    var buttonBlock = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, anchor: Cary.ui.anchor.BOTTOM });
    var nameBlock   = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.name }, this.ctlBlkStyle);
    var styleBlock  = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.style }, this.ctlBlkStyle);
    var widthBlock  = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.lineWidth }, this.ctlBlkStyle);
    var colorBlock  = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.color }, this.ctlBlkStyle);
    var buttonStyle = { width: 70, height: 30, float: 'right' };
    var instance    = this;
    var nameCtl     = new Cary.ui.EditBox ({ parent: nameBlock.htmlObject, text: this.object.name, visible: true }, { display: 'inline', float: 'right', width: 200, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    var widthCtl    = new Cary.ui.EditBox ({ parent: widthBlock.htmlObject, numeric: true, value: this.object.properties ['lineWidth'], visible: true }, { display: 'inline', float: 'right', width: 50, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    var styleCtl    = new Cary.ui.ListBox ({ parent: styleBlock.htmlObject, comboBox: true, items: styleItems, visible: true }, { display: 'inline', float: 'right', width: 120, height: 25, 'margin-right': 20, padding: 0, 'font-size': 17 });
    var colorCtl    = new Cary.ui.EditBox ({ parent: colorBlock.htmlObject, text: this.object.properties ['color'], visible: true }, { display: 'inline', float: 'right', width: 100, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    
    styleCtl.selectByData (this.object.properties ['lineStyle']);
    
    this.cancelButton = new Cary.ui.Button ({ text: stringTable.cancel, parent: buttonBlock.htmlObject, visible: true, onClick: forceClose }, buttonStyle);
    this.okButton     = new Cary.ui.Button ({ text: stringTable.ok, parent: buttonBlock.htmlObject, visible: true, onClick: onOk }, buttonStyle);
    this.buttonBlock  = buttonBlock;
    
    function forceClose ()
    {
        instance.close ();
        
        if ('onClose' in instance.callbacks)
            instance.callbacks.onClose ();
    }
    
    function onOk ()
    {
        instance.object.name                     = nameCtl.getValue ();
        instance.object.properties ['lineStyle'] = styleCtl.getSelectedData ();
        instance.object.properties ['lineWidth'] = widthCtl.getValue ();
        instance.object.properties ['color']     = colorCtl.getValue ();
        
        instance.close (true);
        
        if ('onOk' in instance.callbacks)
            instance.callbacks.onOk (instance.object);
    }
};


Cary.ui.UserPolygonPropsWnd = function (parent, object, callbacks)
{
    Cary.ui.UserPolylinePropsWnd.apply (this, arguments);
};

Cary.ui.UserPolygonPropsWnd.prototype = Object.create (Cary.ui.UserPolylinePropsWnd.prototype);

Cary.ui.UserPolygonPropsWnd.FILL_COLOR_ID = 'fillClr';

Cary.ui.UserPolygonPropsWnd.prototype.onInitialize = function ()
{
    this.setTitle (stringTable.polygonProps);
    this.setHeight (300);
    
    Cary.ui.UserPolylinePropsWnd.prototype.onInitialize.apply (this);
    
    var fillColorBlock  = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.fillColor, id: Cary.ui.UserPolygonPropsWnd.FILL_COLOR_ID }, this.ctlBlkStyle);
    var opacityBlock    = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: stringTable.opacity }, this.ctlBlkStyle);
    var opacityCtl      = new Cary.ui.EditBox ({ parent: opacityBlock.htmlObject, numeric: true, float: true, min: 0, max: 1, step: 0.1, value: this.object.properties ['opacity'], visible: true }, { display: 'inline', float: 'right', width: 50, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    var fillColorCtl    = new Cary.ui.EditBox ({ parent: fillColorBlock.htmlObject, text: this.object.properties ['fillColor'], visible: true }, { display: 'inline', float: 'right', width: 100, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    var instance        = this;
    var parentOkHandler = this.okButton.htmlObject.onclick;
    
    this.okButton.htmlObject.onclick = onOk;
    
    function onOk ()
    {
        instance.object.properties ['opacity']   = opacityCtl.getValue ();
        instance.object.properties ['fillColor'] = fillColorCtl.getValue ();
        
        parentOkHandler ();
    }
};


Cary.ui.MessageBox = function (options, callbacks)
{
    var width;
    var height;
    var title;
    var parent;
    
    this.callbacks = Cary.tools.isNothing (callbacks) ? {} : callbacks;
    this.options   = Cary.tools.isNothing (options) ? {} : options;
    
    width  = 'width' in options ? options.width : 300;
    height = 'height' in options ? options.height : 100;
    title  = 'title' in options ? options.title : 'Information';
    parent = 'parent' in options ? options.parent : document.getElementsByTagName ('body') [0];

    this.text = 'text' in options ? options.text : '';
    
    Cary.ui.Window.apply (this, [{ position: { hcenter: true, vcenter: true, width: width, height: height, absolute: true }, title: title, parent: parent, visible: true }]);
};

Cary.ui.MessageBox.prototype = Object.create (Cary.ui.Window.prototype);

Cary.ui.MessageBox.prototype.onInitialize = function ()
{
    var instance = this;
    
    this.buttonBlock = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, anchor: Cary.ui.anchor.BOTTOM });
    this.dataBlock   = new Cary.ui.ControlBlock ({ parent: this.client, visible: true, text: this.text }, { width: '100%', padding: 10, height: 'fit-content', 'text-align': 'center', 'line-height': 20, 'font-size': 17 });
    this.buttonStyle = { width: 70, height: 30, float: 'right' };
    this.okButton    = new Cary.ui.Button ({ text: 'OK', parent: this.buttonBlock.htmlObject, visible: true, onClick: function () { instance.close (true); } }, this.buttonStyle);
};

Cary.ui.InputBox = function (options, callbacks)
{
    Cary.ui.MessageBox.apply (this, arguments);
};

Cary.ui.InputBox.prototype = Object.create (Cary.ui.MessageBox.prototype);

Cary.ui.InputBox.prototype.onInitialize = function ()
{
    var instance = this;
    var editBox;
    var editWidth = 'editWidth' in this.options ? this.options.editWidth : 200;
    
    Cary.ui.MessageBox.prototype.onInitialize.apply (this, arguments);

    this.dataBlock.htmlObject.style.textAlign = 'left';
    this.dataBlock.htmlObject.innerText       = this.options.prompt;
    
    this.cancelButton = new Cary.ui.Button ({ text: 'Cancel', parent: this.buttonBlock.htmlObject, visible: true, onClick: function () { instance.close (true); } }, this.buttonStyle);

    editBox = new Cary.ui.EditBox ({ parent: this.dataBlock.htmlObject, text: this.options.value, visible: true }, { display: 'inline', float: 'right', width: editWidth, height: 22, 'margin-right': 20, padding: 0, 'font-size': 17 });
    
    this.okButton.setClickHandler (onOk);
    
    function onOk ()
    {
        if ('onOk' in instance.callbacks)
            instance.callbacks.onOk (editBox.getValue ());
        
        instance.close (true);
    }
};


Cary.ui.BrowserWnd = function (parent, options)
{
    var width;
    var height;
    var title;
    var parent;
    
    this.options = Cary.tools.isNothing (options) ? {} : options;
    this.link    = 'link' in options ? options.link : null;
    
    width  = 'width' in options ? options.width : 600;
    height = 'height' in options ? options.height : 500;
    title  = 'title' in options ? options.title : 'Browse document';

    if (Cary.tools.isNothing (parent))
        parent = document.getElementsByTagName ('body') [0];
    
    Cary.ui.Window.apply (this, [{ position: { hcenter: true, vcenter: true, width: width, height: height, visible: true, absolute: true }, title: title, parent: parent, visible: true }]);
};

Cary.ui.BrowserWnd.prototype = Object.create (Cary.ui.Window.prototype);

Cary.ui.BrowserWnd.prototype.onInitialize = function ()
{
    new Cary.ui.Browser ({ source: this.link, parent: this.client, scrollable: true, visible: true }, { left: 0, top: 0, width: '100%', height: '100%', position: 'absolute' });
};

